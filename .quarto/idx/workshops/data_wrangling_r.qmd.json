{"title":"Roadmap","markdown":{"yaml":{"execute":{"echo":true,"message":false,"warning":false,"fig-format":"svg"},"format":{"revealjs":{"highlight-style":"a11y-dark","reference-location":"margin","theme":"csscr_styles.scss","slide-number":true,"code-link":true,"chalkboard":true,"incremental":false,"smaller":true,"preview-links":true,"code-line-numbers":true,"history":false,"progress":true,"link-external-icon":true,"code-annotations":"hover","pointer":{"color":"#b18eb1"}}},"revealjs-plugins":["pointer"]},"headingText":"Roadmap","containsRefs":false,"markdown":"\n\n```{r}\n#| echo: false\n#| cache: false\nrequire(downlit)\nrequire(xml2)\nrequire(tidyverse)\nlibrary(gapminder)\nlibrary(nycflights13)\n#options(width = 90)\n```\n\n\n[Data Wrangling in R]{.custom-title}\n\n[CSSCR Workshop]{.custom-subtitle}\n\n[31 October 2024]{.custom-subtitle2}\n\n[Victoria Sass]{.custom-subtitle3}\n\n\n::: {.incremental}\n* Importing and Exporting Data\n* Manipulating and Summarizing Data \n* Merging Data\n* Tidying and Reshaping Data\n:::\n\n# Importing and Exporting Data{.section-title background-color=\"#4B2E83\"}\n\n## Data Packages\n\nR has a *big* user base.  If you are working with a popular data source, it will often have a devoted R package on *CRAN* or *Github*. \n\n. . . \n\nExamples:\n\n* [`WDI`](https://vincentarelbundock.github.io/WDI/): World Development Indicators (World Bank)\n* [`tidycensus`](https://walker-data.com/tidycensus/): Census and American Community Survey\n* [`quantmod`](https://walker-data.com/tidycensus/): financial data from Yahoo, FRED, Google\n* [`gssr`](https://kjhealy.github.io/gssr/): The General Social Survey Cumulative Data (1972-2021)\n* [`psidR`](https://github.com/floswald/psidR): Panel Study of Income Dynamics (basic & public datasets)\n\n. . . \n\nIf you have an actual data file, you'll have to import it yourself...\n\n## Delimited Text Files\n\nBesides a package, it's easiest when data is stored in a text file. The most commonly encountered delimited file is a **.csv**.\n\n. . . \n\nA comma-separated values (.csv) file looks like the following: \n\n```\n\"Subject\",\"Depression\",\"Sex\",\"Week\",\"HamD\",\"Imipramine\"\n101,\"Non-endogenous\",\"Second\",0,26,NA\n101,\"Non-endogenous\",\"Second\",1,22,NA\n101,\"Non-endogenous\",\"Second\",2,18,4.04305\n101,\"Non-endogenous\",\"Second\",3,7,3.93183\n101,\"Non-endogenous\",\"Second\",4,4,4.33073\n101,\"Non-endogenous\",\"Second\",5,3,4.36945\n103,\"Non-endogenous\",\"First\",0,33,NA\n103,\"Non-endogenous\",\"First\",1,24,NA\n103,\"Non-endogenous\",\"First\",2,15,2.77259\n```\n\n# {data-menu-title=\"`readr``\" background-image=\"images/readr.png\" background-size=\"contain\" background-position=\"center\" .section-title background-color=\"#B7A57A\"}\n\n## `readr`\n\nR has some built-in functions for importing data, such as `read.table()` and `read.csv()`. \n\n. . . \n\nThe `readr` package provides similar functions, like `read_csv()`, that have slightly better features:\n\n::: {.incremental}\n* Faster!\n* Better defaults (e.g. doesn't automatically convert characters to factors)\n* A *bit* smarter about dates and times\n* Loading progress bars for large files\n:::\n\n. . . \n\n`readr` is one of the core `tidyverse` packages so loading `tidyverse` will load it too:\n\n```{r}\nlibrary(tidyverse)\n```\n\n. . . \n\nAlternatively, you can just load `readr` like so:\n\n```{r}\n#| eval: false\nlibrary(readr)\n```\n\n## `readr` Importing Example\n\nLet's import some data about song ranks on the Billboard Hot 100 in 2000:\n\n```{r}\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\")\n```\n\n. . . \n\nHow do we know it loaded? \n\n. . . \n\nLet's look at it!\n\n```{r}\n#| output-location: fragment\nglimpse(billboard_2000_raw)\n```\n\n## Alternate Solution\n\nWhen you import data from an external file you'll also see it in the Global Environment tab in the upper-right pane of RStudio: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n::: {.fragment}\nYou can also import the data manually!\n\nIn the upper right-hand pane of RStudio (make sure you're in the Environment tab), select:\n\n`Import Dataset > From Text (readr)` and browse to the file on your computer^[Ideally you've saved it in your project folder!].\n:::\n\n::: {.fragment}\n**Once you've imported the data, you can `copy/paste` the import code from the console into your file!!**\n\nThis makes the process *reproducible!*\n:::\n:::\n::: {.column width=\"50%\"}\n![](images/data_global_env.png)\n\n:::\n\n::::\n\n## Manual Data Import\n\n![](images/data_import_manual.png){fig-align=\"center\"}\n\n## Specifying `NA`s \n\nSometimes a particular dataset or file read from a different software will code `NA`s differently than `R`. If that's the case, you can add additional specifications to `read_csv` for what to read in as `NA`.  \n\n\n```{r}\n#| eval: false\n#| code-line-numbers: \"|2\"\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               na = c(\"N/A\", \"999\"))\n```\n\n## Skipping lines\n\nDepending on how the data were input, there may be several lines that precede the beginning of the data table you're interested in importing. You can skip these lines of metadata with the `skip` argument:\n\n```{r}\n#| eval: false\n#| code-line-numbers: \"|2\"\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               skip = 1)\n```\n\n## Variable names\n\n`read_csv` will automatically take the first row as column names. If you want to rename them you can save yourself some time recoding later on if you specify your preferred variable names upfront with the `col_names` argument. \n\n. . . \n\nIt takes a character vector to be used as column names (in their order of appearance). \n\n```{r}\nbillboard_renamed <- read_csv(file = \"data/billboard.csv\",\n                              col_names = c(\"year\", \"artist\", \"track\", \"time\", \"date_entered\", \n                                            paste(\"wk\", 1:76, sep = \"_\"))) # <1>\n\nbillboard_renamed |>  names() |> head(10) # <2>\n```\n1. First few entries: \"wk_1\"  \"wk_2\"  \"wk_3\"\n2. `names` returns the column names.\n\n. . . \n\nIf you don't have any variable names you can specify that instead. \n\n```{r}\n#| eval: false\n#| code-line-numbers: \"|2\"\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_names = FALSE) \n```\n\n## Snake Case\n\nIf you simply want to change your variables to snake case (all lower case; words separated by `_`), you can use the function `clean_names()` from the `janitor` package which replaces other punctuation separators with `_`. \n\n```{r}\n#| output-location: fragment\n# Download package first\n# install.packages(\"janitor\") # <3> \n\n# Create new object for renamed data\nbillboard_renamed <- billboard_2000_raw |> \n  janitor::clean_names(numerals = \"right\") # <4>\n\nbillboard_renamed |>  names() |> head(10)\n```\n\n3. Run in the console first. \n4. You can call a function without loading its package by specifying its package name followed by `::` before it; <br> The `numerals` argument specifies if you additionally want to put a separator before a number. \n\n## Other Data File Types with `readr`\n\nThe other functions in `readr` employ a similar approach to `read_csv` so the trick is just knowing which to use for what data type. \n\n. . . \n\n* `read_csv2` is separated by semicolons (instead of commas)\n* `read_tsv` is separated by tabs\n* `read_delim` guesses the delimiter\n* `read_fwf` reads in fixed-width-files\n* `read_table` is a variation of `fwf` where columns are separated by white space\n* `read_log` reads in Apache-style log files\n\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](images/readxl.png){.absolute top=185 left=135}\n:::\n::: {.column width=\"50%\"}\n* For Excel files (`.xls` or `.xlsx`), use package [`readxl`](https://readxl.tidyverse.org/)^[Functions have additional arguments to read in specific sheets or a range of cells.]\n:::\n::::\n\n::: aside\nNote: For Excel files and Googlesheets You **won't** keep text formatting, color, comments, or merged cells. See the [`openxlsx`](https://ycphs.github.io/openxlsx/) package for those capabilities. Also, [`tidyxl`](https://github.com/nacnudus/tidyxl) can help import non-tabular data from Excel. \n:::\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](images/googlesheets4.png){.absolute top=185 left=135}\n:::\n::: {.column width=\"50%\"}\n* For Excel files (`.xls` or `.xlsx`), use package [`readxl`](https://readxl.tidyverse.org/)^[Functions have additional arguments to read in specific sheets or a range of cells.]\n* For Google Docs Spreadsheets, use package [`googlesheets4`](https://googlesheets4.tidyverse.org/)^[Very similar to `readxl` with some slight variations you can read about [here](https://r4ds.hadley.nz/spreadsheets.html#google-sheets).]\n:::\n::::\n\n::: aside\nNote: For Excel files and Googlesheets You **won't** keep text formatting, color, comments, or merged cells. See the [`openxlsx`](https://ycphs.github.io/openxlsx/) package for those capabilities. Also, [`tidyxl`](https://github.com/nacnudus/tidyxl) can help import non-tabular data from Excel. \n:::\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](images/haven.png){.absolute top=185 left=135}\n:::\n::: {.column width=\"50%\"}\n* For Excel files (`.xls` or `.xlsx`), use package [`readxl`](https://readxl.tidyverse.org/)^[Functions have additional arguments to read in specific sheets or a range of cells.]\n* For Google Docs Spreadsheets, use package [`googlesheets4`](https://googlesheets4.tidyverse.org/)^[Very similar to `readxl` with some slight variations you can read about [here](https://r4ds.hadley.nz/spreadsheets.html#google-sheets).]\n* For Stata, SPSS, and SAS files, use package [`haven`](https://haven.tidyverse.org/)^[SAS, SPSS, and Stata have so-called \"labelled\" vectors for which `haven` provides a [class](https://haven.tidyverse.org/reference/index.html#labelled-vectors) to represent in `R`. Alternatively, you can get rid of them with [these functions](https://haven.tidyverse.org/reference/index.html#remove-attributes).]\n:::\n::::\n\n::: aside\nNote: For Excel files and Googlesheets You **won't** keep text formatting, color, comments, or merged cells. See the [`openxlsx`](https://ycphs.github.io/openxlsx/) package for those capabilities. Also, [`tidyxl`](https://github.com/nacnudus/tidyxl) can help import non-tabular data from Excel. \n:::\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks: \n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#B7A57A,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#B7A57A,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#B7A57A,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#B7A57A,color:#000000,stroke:#000000\n\n```\n\n## Most Common Issue with Reading in Data\n\nThe most common problem that occurs when reading in data is having mixed data. Most often, given the heuristic provided in the last slide, `R` will parse a variable as a character string to preserve whatever it contains. \n\n. . . \n\nLet's actually look at how the billboard data was read in: \n\n```{r}\n#| output-location: fragment\nglimpse(billboard_2000_raw) \n```\n\n## What Went Wrong? \n\nSince `readr` uses the values in the first 1000 rows to guess the type of the column (logical, numeric, date/date-time, character), if the first 1000 rows don't have any data, they will be coded as logical variables. \n\n. . . \n\nThere are not many songs in the data that charted for 60+ weeks—and none in the first 1000 that charted for 66+ weeks!\n\n. . . \n\n::: {.callout-note icon=false}\n\n## <span style=\"color:blue\">{{< fa circle-info >}}</span> \\ `NA` is logical?\n\n```{r}\n#| output-location: fragment\nclass(c(T, F, NA, FALSE, TRUE))\nclass(c(1, NA, 17.5, 5.3, NA)) # <5>\nclass(as.Date(c(NA, \"2023-10-31\", \"1986-06-21\", \"1997-01-15\"), tz = \"America/Los_Angeles\")) # <6>\nclass(c(\"apple\", NA, \"mango\", \"blackberry\", \"plum\")) \nclass(c(NA, NA, NA, NA, NA))\n```\n\n5. `class` returns the data type of its first argument. \n6. `as.Date` turns a character string of dates into an official date class in Base `R`. If we had an accompanying time stamp we would need to use `as.POSIXct` which turns a character string of dates and times into an official date-time class in Base `R`. \n:::\n\n::: aside\nTechnically, `NA`s can be any data type depending upon what they are grouped with. However, by themselves they are a logical indicator of missing data, so their class is logical. \n:::\n\n## Column types\n\nSince the `wk*` variables should all be read in as integers, we can specify this explicitly with the `col_types` argument. \n\n. . . \n\n```{r}\n#| output-location: fragment\n# Create character string of shortcode column types\nbb_types <- paste(c(\"icctD\", rep(\"i\", 76)), collapse=\"\") # <7>\nbb_types \n```\n\n7. You can short-code column types with `i` = integer, `c` = character, `t` = time, `D` = date. <br> The `collapse` argument collapses the first two arguments into one complete character string.\n\n. . . \n\n<br>\n\n```{r}\n# re-read in data with column types specified\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_types = bb_types) # <8>\n```\n8. See all column types and short codes [here](https://readr.tidyverse.org/reference/cols.html).\n\n## Column types\n\nTo specify a default column type you can use `.default` like so: \n\n```{r}\n#| eval: false\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_types = cols(.default = col_character())) \n```\n\n. . . \n\n<br>\n\nAnother useful helper is `cols_only()` for when you only want to read in a subset of all available variables.\n\n```{r}\n#| eval: false\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_types = cols_only(x = col_character)) \n```\n\n. . . \n\n<br>\n\nIn summary, the `col_types` argument gives you greater control over how your data are read in and can save you recoding time down the road and/or point out where your data are behaving differently than you expect. \n\n## Writing Delimited Files\n\nGetting data out of R into a delimited file is very similar to getting it into R:\n\n```{r}\n#| eval: false\nwrite_csv(billboard_2000_raw, path = \"data/billboard_data.csv\")\n```\n\nThis saved the data we pulled off the web in a file called `billboard_data.csv` in the `data` folder of my working directory.\n\n. . . \n\nHowever, saving data in this way will not preserve `R` data types since delimited files code everything as a character string. \n\n. . . \n\nTo save `R` objects and all associated metadata you have two options: \n\n::: {.panel-tabset}\n\n### `.Rds` format:\n\n* Used for single objects, doesn't save the original object name\n* Save: `write_rds(old_object_name, \"path.Rds\")`\n* Load: `new_object_name <- read_rds(\"path.Rds\")`\n\n### `.Rdata` or `.Rda` format:\n\n* Used for saving multiple files where the original object names are preserved\n* Save: `save(object1, object2, ... , file = \"path.Rdata\")`\n* Load: `load(\"path.Rdata\")` without assignment operator\n\n:::\n\n## Writing Other File-Types\n\n::: {.panel-tabset}\n\n### `writexl`\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n* `write_xlsx()` writes to an xlsx file\n:::\n\n::: {.column width=\"40%\"}\n![](images/writexl.png){width=50%}\n:::\n\n::::\n\n### `googlesheets4`\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n* `sheet_write()` or `write_sheet()` (over)writes new data into a Sheet\n* `gs4_create()` creates a new Sheet\n* `sheet_append()` appends rows to a sheet\n* `range_write()` (over)writes new data into a range\n* `range_flood()` floods a range of cells\n* ``range_clear()` clears a range of cells\n:::\n\n::: {.column width=\"40%\"}\n![](images/googlesheets4.png){width=50%}\n:::\n\n::::\n\n### `haven`\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n* `write_dta()` writes Stata DTA files\n* `write_sav()` writes SPSS files\n* `write_xpt()` writes SAS transport files\n:::\n\n::: {.column width=\"40%\"}\n![](images/haven.png){width=50%}\n:::\n\n::::\n\n:::\n\n# Manipulating and Summarizing Data{.section-title background-color=\"#4B2E83\"}\n\n## Death to Spreadsheets\n\nTools like *Excel* or *Google Sheets* let you manipulate spreadsheets using functions.\n\n::: {.incremental}\n* Spreadsheets are *not reproducible*: It's hard to know how someone changed the raw data!\n* It's hard to catch mistakes when you use spreadsheets^[Don't be the next sad Research Assistant who makes headlines with an Excel error! ([Reinhart & Rogoff, 2010](http://www.bloomberg.com/news/articles/2013-04-18/faq-reinhart-rogoff-and-the-excel-error-that-changed-history))].\n:::\n \n. . .  \n \nWe want to know how to use `R` to manipulate data more *transparently* and *reproducibly*.\n\n# Logical Operators{.section-title background-color=\"#B7A57A\"}\n\n## Data types in `R`\n\nThere are a variety of data types in `R`: \n\n. . . \n\n* Factors\n* Date/Date-time\n* Logical\n* Numeric\n* Missing Values\n* Strings\n\n## Data types in `R`\n\nThere are a variety of data types in `R`: \n\n* Factors\n* Date/Date-time\n* <span style=\"color:#e15759\">Logical</span>\n* Numeric\n* Missing Values\n* Strings\n\n## Logical Operators in `R`\n  \n#### Comparing objects\n:::: {.columns}\n\n::: {.column width=\"19%\"}\n::: {.fragment}\n* `==`: \n* `!=`: \n* `>`, `>=`, `<`, `<=`: \n* `%in%`: \n:::\n:::\n\n::: {.column width=\"81%\"}\n\n::: {.fragment}\n* is equal to^[Note: there are TWO equal signs here!]\n* not equal to\n* less than, less than or equal to, etc.\n* used when checking if equal to one of several values\n:::\n:::\n\n::::\n\n:::{.fragment}\n#### Combining comparisons\n:::\n\n:::: {.columns}\n\n::: {.column width=\"19%\"}\n::: {.fragment}\n* `&`: \n* `|`: \n* `!`: \n* `xor()`:\n:::\n:::\n\n::: {.column width=\"81%\"}\n\n::: {.fragment .bullet-spacing}\n* **both** conditions need to hold (AND)\\\n* **at least one** condition needs to hold (OR)\\\n* **inverts** a logical condition (`TRUE` becomes `FALSE`, vice versa)\\\n* **exclusive OR** (i.e. x or y but NOT both)\n:::\n:::\n\n::::\n\n::: aside\nYou may also see `&&` and `||` but they are what's known as short-circuiting operators and are not to be used in `dplyr` functions (used for programming not data manipulation); they'll only ever return a single `TRUE` or `FALSE`.\n:::\n\n## Logical Summaries\n\n:::: {.columns}\n\n::: {.column width=\"19%\"}\n::: {.fragment}\n* `any()`: \n* `all()`: \n:::\n:::\n\n::: {.column width=\"81%\"}\n\n::: {.fragment}\n* the equivalent of `|`; it’ll return `TRUE` if there are any `TRUE`’s in x\n* the equivalent of `&`; it’ll return `TRUE` only if all values of x are `TRUE`’s\n:::\n:::\n\n::::\n\n. . .\n\n```{r}\nC <- c(5, 10, NA, 10, 20, NA)\nany(C <= 10) \nall(C <= 20) # <1> \nall(C <= 20, na.rm = TRUE) # <2>\nmean(C, na.rm = TRUE) # <3> \n\n```\n1. Like other summary functions, they'll return `NA` if there are any missing values present and it's `FALSE`. \n2. Use `na.rm = TRUE` to remove `NA`s prior to evaluation. \n3. When you evaluate a logical vector numerically, `TRUE` = 1 and `FALSE` = 0. This makes `sum()` and `mean()` useful when summarizing logical functions (sum gives number of `TRUE`s and mean gives the proportion). \n\n## Conditional transformations\n\n<ins>**`if_else()`**</ins>\n\nIf you want to use one value when a condition is `TRUE` and another value when it’s `FALSE`.\n\n. . . \n\n```{r}\n#| eval: false\nif_else(condition = \"A logical vector\", \n        true = \"Output when condition is true\", \n        false = \"Output when condition is false\")\n```\n\n. . . \n\n```{r}\nx <- c(-3:3, NA)\nif_else(x > 0, \"+ve\", \"-ve\", \"???\") # <4> \n```\n4. There’s an optional fourth argument, `missing` which will be used if the input is `NA`.\n\n. . . \n\n<ins>**`case_when()`**</ins>\n\nA very useful extension of `if_else()` for multiple conditions^[Note that if multiple conditions match in `case_when()`, only the first will be used. \n]. \n\n. . . \n\n```{r}\ncase_when(\n  x == 0   ~ \"0\",\n  x < 0    ~ \"-ve\", \n  x > 0    ~ \"+ve\",\n  is.na(x) ~ \"???\" # <5>\n) # <6> \n```\n\n5. Use `.default` if you want to create a “default”/catch all value. \n6. Both functions require compatible types: i.e. numerical and logical, strings and factors, dates and datetimes, `NA` and everything. \n\n# {data-menu-title=\"`dplyr`\" background-image=\"images/dplyr.png\" background-size=\"contain\" background-position=\"center\" .section-title background-color=\"#B7A57A\"}\n\n## `dplyr`\n\nToday, we'll use tools from the `dplyr` package to manipulate data! \n\n* `dplyr` is part of the *Tidyverse*, and included in the `tidyverse` package. \n\n```{r}\nlibrary(tidyverse)\n```\n\n. . . \n\nTo demonstrate data transformations we're going to use the `nycflights13` dataset, which you'll need to download and load into `R`\n\n```{r}\n# Download and load data\n# install.packages(\"nycflights13\") # <7>\nlibrary(nycflights13) # <8>\n```\n\n7. Run in console. \n8. Load into `R` session. \n\n. . . \n\n`nycflights13` includes five dataframes^[Note these are separate data frames, each needing to be loaded separately:], some of which contain missing data (`NA`):\n\n```{r}\n#| eval: false\ndata(flights) # <9> \ndata(airlines) # <10>\ndata(airports) # <11>\ndata(planes) # <12>\ndata(weather) # <13>\n```\n\n9. flights leaving JFK, LGA, or EWR in 2013\n10. airline abbreviations\n11. airport metadata\n12. airplane metadata\n13. hourly weather data for JFK, LGA, and EWR\n\n## `dplyr` Basics\n\nAll `dplyr` functions have the following in common: \n\n::: {.incremental}\n1. The first argument is always a data frame.\n2. The subsequent arguments typically describe which columns to operate on, using the variable names (without quotes).\n3. The output is always a new data frame.\n:::\n\n. . . \n\nEach function operates either on rows, columns, groups, or entire tables.\n\n. . . \n\nTo save the transformations you've made to a data frame you'll need to save the output to a new object. \n\n# Subsetting data{.section-title background-color=\"#B7A57A\"}\n\n## Subset Rows: `filter()`\n\nWe often get *big* datasets, and we only want some of the entries. We can subset rows using `filter()`.\n\n. . . \n\n```{r}\ndelay_2hr <- flights |> \n  filter(dep_delay > 120) # <14>\ndelay_2hr # <15>\n```\n\n14. Here's where we'll use a lot of logical operators. Make sure to use `==` not `=` to test the logical condition. \n15. Now, `delay_2hr` is an object in our environment which contains rows corresponding to flights that experienced at least a 2 hour delay.\n\n## Subset Columns: `select()`\n\nWhat if we want to keep every observation, but only use certain variables? Use `select()`!\n\n. . . \n\nWe can select columns by name: \n\n```{r}\nflights |> \n  select(year, month, day) # <16>\n```\n\n16. You can use a `-` before a variable name or a vector of variables to drop them from the data (i.e. <br> `select(-c(year, month, day))`).\n\n## Subset Columns: `select()`\n\nWhat if we want to keep every observation, but only use certain variables? Use `select()`!\n\n\nWe can select columns between variables (inclusive): \n\n```{r}\nflights |> \n  select(year:day) # <17>\n```\n\n17. Add a `!` before `year` and you'll drop this group of variables from the data. \n\n## Subset Columns: `select()`\n\nWhat if we want to keep every observation, but only use certain variables? Use `select()`!\n\nWe can select columns based on a condition: \n\n```{r}\nflights |> \n  select(where(is.character)) # <18>\n```\n\n18. There are a number of helper functions you can use with `select()` including `starts_with()`, `ends_with()`, `contains()` and `num_range()`. Read more about these and more [here](https://tidyselect.r-lib.org/reference/index.html). \n\n## Finding Unique Rows: `distinct()`\n\nYou may want to find the unique combinations of variables in a dataset.  Use `distinct()`\n\n. . . \n\n```{r}\nflights |> \n  distinct(origin, dest) # <19>\n```\n\n19. Find all unique origin and destination pairs.\n\n## `distinct()` drops variables!\n\nBy default, `distinct()` drops unused variables. If you don't want to drop them, add the argument `.keep_all = TRUE`:\n\n. . . \n\n```{r}\nflights |> \n  distinct(origin, dest, .keep_all = TRUE) # <20> \n```\n\n20. It’s not a coincidence that all of these distinct flights are on January 1: `distinct()` will find the first occurrence of a unique row in the dataset and discard the rest. Use `count()` if you're looking for the number of occurrences. \n\n## Count Unique Rows: `count()` \n\n. . . \n\n```{r}\nflights |>\n  count(origin, dest, sort = TRUE) # <21>\n```\n\n21. `sort = TRUE` arranges them in descending order of number of occurrences. \n\n# Modifying data{.section-title background-color=\"#B7A57A\"}\n\n## Sorting Data by Rows: `arrange()`\n\nSometimes it's useful to sort rows in your data, in ascending (low to high) or descending (high to low) order. We do that with `arrange()`.\n\n. . . \n\n```{r}\nflights |> \n  arrange(year, month, day, dep_time) # <22> \n```\n\n22. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns.\n\n## Sorting Data by Rows: `arrange()`\n\nTo sort in descending order, using `desc()` within `arrange()`\n\n. . . \n\n```{r}\nflights |> \n  arrange(desc(dep_delay))\n```\n\n## Rename Variables: `rename()`\n\nYou may receive data with unintuitive variable names. Change them using `rename()`.\n\n. . . \n\n```{r}\nflights |> \n  rename(tail_num = tailnum) # <23>\n```\n\n23. `rename(new_name = old_name)` is the format. You can use `janitor::clean_names()` if you want to automate this process for a lot of variables. \n\n. . . \n\n::: {.callout-caution icon=false}\n## <span style=\"color:tomato\">{{< fa exclamation-triangle >}}</span> Variable Syntax\nI recommend **against** using spaces in a name! It makes things *really hard* sometimes!!\n:::\n\n## Create New Columns: `mutate()`\n\nYou can add new columns to a data frame using `mutate()`. \n\n. . . \n\n```{r}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1 # <24> \n  )\n```\n\n24. By default, `mutate()` adds new columns on the right hand side of your dataset, which makes it difficult to see if anything happened. You can use the `.before` argument to specify which numeric index (or variable name) to move the newly created variable to. `.after` is an alternative argument for this.   \n\n## Specifying Variables to Keep: `mutate()`\n\nYou can specify which columns to keep with the `.keep` argument:\n\n```{r}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\" # <25> \n  )\n```\n\n25. \"used\" retains only the variables used to create the new variables, which is useful for checking your work. Other options include: \"all,\" \"unused,\" and \"none.\"\n\n## Move Variables Around: `relocate()`\n\nYou might want to collect related variables together or move important variables to the front. Use `relocate()`!\n\n```{r}\nflights |> \n  relocate(time_hour, air_time) # <26>\n```\n\n26. By default `relocate()` moves variables to the front but you can also specify where to put them using the `.before` and `.after` arguments, just like in `mutate()`.\n\n# Summarizing data{.section-title background-color=\"#B7A57A\"}\n\n## Grouping Data: `group_by()`\n\nIf you want to analyze your data by specific groupings, use `group_by()`:\n\n```{r}\nflights |> \n  group_by(month) # <27>\n```\n\n27. `group_by()` doesn’t change the data but you’ll notice that the output indicates that it is “grouped by” month `(Groups: month [12])`. This means subsequent operations will now work “by month”.\n\n## Summarizing Data: `summarize()`\n\n**`summarize()`** calculates summaries of variables in your data:\n\n::: {.incremental}\n* Count the number of rows\n* Calculate the mean\n* Calculate the sum\n* Find the minimum or maximum value\n:::\n\n. . . \n\nYou can use any function inside `summarize()` that aggregates *multiple values* into a *single value* (like `sd()`, `mean()`, or `max()`).\n\n## `summarize()` Example\n\nLet's see what this looks like in our flights dataset:\n\n. . . \n\n```{r}\nflights |> \n  summarize(\n    avg_delay = mean(dep_delay) # <28> \n  )\n```\n\n28. The `NA` produced here is a result of calling `mean` on `dep_delay`. Any summarizing function will return `NA` if **any** of the values are `NA`. We can set `na.rm = TRUE` to change this behavior. \n\n## `summarize()` Example\n\nLet's see what this looks like in our flights dataset:\n\n```{r}\nflights |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE) \n  )\n```\n\n## Summarizing Data by Groups\n\nWhat if we want to summarize data by our groups? Use `group_by()` **and** `summarize()`\n\n. . . \n\n```{r}\nflights |> \n  group_by(month) |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE)\n  )\n```\n\n. . . \n\nBecause we did `group_by()` with `month`, then used `summarize()`, we get *one row per value of `month`*!\n\n## Summarizing Data by Groups\n\nYou can create any number of summaries in a single call to summarize().\n\n```{r}\nflights |> \n  group_by(month) |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n() # <29>\n  )\n```\n\n29. `n()` returns the number of rows in each group. \n\n## Grouping by Multiple Variables <span style=\"color:#B7A57A\">{{< fa scroll >}}</span> {.scrollable} \n\n```{r}\ndaily <- flights |> \n  group_by(year, month, day)  \ndaily\n```\n\n. . . \n\n::: {.callout-tip icon=false}\n## <span style=\"color:green\">{{< fa info-circle >}}</span> Summary & Grouping Behavior\nWhen you summarize a tibble grouped by more than one variable, each summary peels off the last group. You can change the default behavior by setting the `.groups` argument to a different value, e.g., \"drop\" to drop all grouping or \"keep\" to preserve the same groups. The default is \"drop_last\". \n:::\n\n## Remove Grouping: `ungroup()`\n\n```{r}\ndaily |> \n  ungroup() \n```\n\n## New Alternative for Grouping: `.by`\n\n```{r}\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month # <30>\n  )\n```\n\n30. `.by` works with all verbs and has the advantage that you don’t need to use the `.groups` argument to suppress the grouping message or `ungroup()` when you’re done.\n\n## Select Specific Rows Per Group: `slice_*`\n\nThere are five handy functions that allow you extract specific rows within each group:\n\n::: {.incremental}\n* `df |> slice_head(n = 1)` takes the first row from each group.\n* `df |> slice_tail(n = 1)` takes the last row in each group.\n* `df |> slice_min(x, n = 1)` takes the row with the smallest value of column x.\n* `df |> slice_max(x, n = 1)` takes the row with the largest value of column x.\n* `df |> slice_sample(n = 1)` takes one random row.\n:::\n\n. . . \n\nLet's find the flights that are most delayed upon arrival at each destination. \n\n\n## Select Specific Rows Per Group: `slice_*` \n\n\n```{r}\nflights |> \n  group_by(dest) |> \n  slice_max(arr_delay, n = 1) |> # <31>\n  relocate(dest) \n```\n\n31. You can vary `n` to select more than one row, or instead of `n =`, you can use `prop = 0.1` to select (e.g.) 10% of the rows in each group.\n\n::: aside\nThere are 105 groups but 108 rows! Why? `slice_min()` and `slice_max()` keep tied values so `n = 1` means \"give us all rows with the highest value.\" If you want exactly one row per group you can set `with_ties = FALSE`.\n:::\n\n# Merging Data {.section-title background-color=\"#4B2E83\"}\n\n## Why Merge Data?\n\nIn practice, we often collect data from different sources. To analyze the data, we usually must first combine (merge) them.\n\n. . . \n\nFor example, imagine you would like to study county-level patterns with respect to age and grocery spending. However, you can only find,\n\n* County level age data from the US Census, and \n* County level grocery spending data from the US Department of Agriculture\n\n. . . \n\nMerge the data!!\n\n. . . \n\nTo do this we'll be using the various **join** functions from the `dplyr` package. \n\n## Joining in Concept\n\nWe need to think about the following when we want to merge data frames A and B:\n\n::: {.fragment}\n* Which rows are we keeping from each data frame?\n:::\n\n::: {.fragment}\n* Which columns are we keeping from each data frame?\n:::\n\n::: {.fragment .fade-in}\n::: {.fragment .highlight-red}\n* Which variables determine whether rows match?\n:::\n:::\n\n## Keys\n\nKeys are the way that two datasets are connected to one another. The two types of keys are: \n\n::: {.incremental}\n1. **Primary**: a variable or set of variables that uniquely identifies each observation.\n    i) When more than one variable makes up the primary key it's called a **compound key**\n2. **Foreign**: a variable (or set of variables) that corresponds to a primary key in another table.\n:::\n\n## Primary Keys <span style=\"color:#B7A57A\">{{< fa scroll >}}</span> {.scrollable} \n\nLet's look at our data to gain a better sense of what this all means. \n\n::: {.panel-tabset}\n\n### `airlines` \n\n::: {.smaller-font}\n`airlines` records two pieces of data about each airline: its carrier code and its full name. You can identify an airline with its two letter carrier code, making `carrier` the primary key.\n:::\n\n```{r}\nairlines \n```\n\n### `airports`\n\n::: {.smaller-font}\n`airports` records data about each airport. You can identify each airport by its three letter airport code, making `faa` the primary key.\n:::\n\n```{r}\nairports\n```\n\n\n### `planes`\n\n::: {.smaller-font}\n`planes` records data about each plane. You can identify a plane by its tail number, making `tailnum` the primary key.\n:::\n\n```{r}\nplanes\n```\n\n\n### `weather`\n\n::: {.smaller-font}\n`weather` records data about the weather at the origin airports. You can identify each observation by the combination of location and time, making `origin` and `time_hour` the compound primary key.\n:::\n\n```{r}\nweather\n```\n\n### `flights`\n\n::: {.smaller-font}\n`flights` has three variables (`time_hour`, `flight`, `carrier`) that uniquely identify an observation. More significantly, however, it contains **foreign keys** that correspond to the primary keys of the other datasets.\n:::\n\n```{r}\nflights\n```\n\n:::\n\n\n## Foreign Keys\n\n![Note: grey shading indicates the primary key for that particular dataset.](images/relational.png){fig-align=\"center\"}\n\n::: {.incremental}\n* `flights$origin` --> `airports$faa`\n* `flights$dest` --> `airports$faa`\n* `flights$origin`-`flights$time_hour` --> `weather$origin`-`weather$time_hour`.\n* `flights$tailnum` --> `planes$tailnum`\n* `flights$carrier` --> `airlines$carrier`\n:::\n\n## Checking Keys\n\nA nice feature of these data are that the primary and foreign keys have the same name and almost every variable name used across multiple tables has the same meaning.^[With the exception of `year`: it means year of departure in `flights` and year of manufacture in `planes`. ] This isn't always the case!^[We'll cover how to handle this shortly.]\n\n. . . \n\nIt is good practice to make sure your primary keys actually uniquely identify an observation and that they don't have any missing values. \n\n. . . \n\n```{r}\n#| output-location: fragment\nplanes |> \n  count(tailnum) |> # <1>\n  filter(n > 1) # <1> \n```\n\n1. If your primary keys uniquely identify each observation you'll get an empty tibble in return. \n\n. . . \n\n```{r}\nplanes |> \n  filter(is.na(tailnum)) # <2>\n```\n\n2. If none of your primary keys are missing you'll get an empty tibble in return here too. \n\n## Surrogate Keys\n\nSometimes you'll want to create an index of your observations to serve as a surrogate key because the compound primary key is not particlarly easy to reference. \n\n. . . \n\nFor example, our `flights` dataset has three variables that uniquely identify each observation: `time_hour`, `carrier`, `flight`.\n\n. . . \n\n```{r}\n#| output-location: fragment\nflights2 <- flights |> \n  mutate(id = row_number(), .before = 1) # <3> \nflights2\n```\n\n3. `row_number()` simply specifies the row number of the dataframe. \n\n## Basic (Equi-) Joins\n\nAll join functions have the same basic interface: they take a **pair** of data frames and return **one** data frame. \n\n. . . \n\nThe order of the rows and columns is primarily going to be determined by the first data frame. \n\n. . . \n\n`dplyr` has two types of joins: *mutating* and *filtering.* \n\n<br>\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n#### Mutating Joins \nAdd new variables to one data frame from matching observations from another data frame. \n\n* `left_join()`\n* `right_join()`\n* `inner_join()`\n* `full_join()`\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n#### Filtering Joins \nFilter observations from one data frame based on whether or not they match an observation in another data frame. \n\n* `semi_join()`\n* `anti-join()`\n:::\n\n:::\n\n::::\n\n## `Mutating Joins`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup.png)\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup2.png)\n:::\n:::\n\n::::\n\n## `left_join()` <span style=\"color:#B7A57A\">{{< fa scroll >}}</span> {.scrollable} \n\n![](images/joins_left.png){fig-align=\"center\"}\n\n::: aside\n::: {.incremental}\n* The most common type of join\n* Appends columns from `y` to `x` by the rows in `x`\n    + `NA` added if there is nothing from `y`\n* Natural join: when all variables that appear in both datasets are used as the join key\n    + If the join_by() argument is not specified, `left_join()` will automatically join by all columns that have names and values in common. \n:::\n:::\n\n## `left_join` in `nycflights13`\n\n```{r}\nflights2 <- flights |> \n  select(year, time_hour, origin, dest, tailnum, carrier)\n```\n\nWith only the pertinent variables from the `flights` dataset, we can see how a `left_join` works with the `airlines` dataset. \n\n```{r}\n#| output-location: fragment\n#| message: true\nflights2 |>\n  left_join(airlines)\n```\n\n## Different variable meanings\n\n```{r}\n#| output-location: fragment\n#| message: true\nflights2 |> \n  left_join(planes)\n```\n\n. . . \n\nWhen we try to do this, however, we get a bunch of `NA`s. Why? \n\n## Different variable meanings\n\n```{r}\n#| message: true\nflights2 |> \n  left_join(planes)\n```\n\n*Join is trying to use tailnum and year as a compound key.* While both datasets have `year` as a variable, they mean different things. Therefore, we need to be explicit here about what to join by. \n\n## Different variable meanings\n\n```{r}\n#| output-location: fragment\nflights2 |> \n  left_join(planes, join_by(tailnum)) # <4>\n```\n\n4. `join_by(tailnum)` is short for `join_by(tailnum == tailnum)` making these types of basic joins equi joins. \n\n::: aside\nWhen you have the same variable name but they mean different things you can specify a particular suffix with the `suffix` argument.\n:::\n\n## Different variable names\n\nIf you have keys that have the same meaning (values) but are named different things in their respective datasets you'd also specify that with `join_by()`\n\n. . . \n\n```{r}\n#| output-location: fragment\nflights2 |> \n  left_join(airports, join_by(dest == faa)) # <5>\n```\n\n5. `by = c(\"dest\" = \"faa\")` was the former syntax for this and you still might see that in older code. \n\n. . . \n\nThis will match `dest` to `faa` for the join and then drop `faa`. \n\n## Different variable names\n\nYou can request `dplyr` to keep both keys with `keep = TRUE` argument. \n\n. . . \n\n```{r}\n#| output-location: fragment\nflights2 |> \n  left_join(airports, join_by(dest == faa), keep = TRUE) \n```\n\n## `right_join()`\n\n![Has the same interface as a left_join but keeps all rows in `y` instead of `x`](images/joins_right.png){fig-align=\"center\"}\n\n## `inner_join()`\n\n![Has the same interface as a left_join but only keeps rows that occur in both x and y](images/joins_inner.png){fig-align=\"center\"}\n\n## `full_join()`\n\n![Has the same interface as a left_join but keeps all rows in either x or y](images/joins_full.png){fig-align=\"center\"}\n\n## `Filtering Joins`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup.png)\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup2.png)\n:::\n:::\n\n::::\n\n## `semi_join()`\n\n![Keeps all rows in x that have a match in y](images/joins_semi.png){fig-align=\"center\"}\n\n\n## `semi_join()` in `nycflights13`\n\nWe could use a semi-join to filter the airports dataset to show just the origin airports.\n\n. . . \n\n```{r}\n#| output-location: fragment\nairports |> \n  semi_join(flights2, join_by(faa == origin))\n```\n\n\n## `anti_join()`\n\n![Returns all rows in x that don’t have a match in y](images/joins_anti.png){fig-align=\"center\"}\n\n## `anti_join()` in `nycflights13`\n\nWe can find rows that are missing from airports by looking for flights that don’t have a matching destination airport.\n\n. . . \n\n```{r}\n#| output-location: fragment\nairports |> \n  anti_join(flights2, join_by(faa == origin))\n```\n\n::: aside\nThis type of join is useful for finding missing values that are implicit in the data (i.e. `NA`s that don't show up in the data but only exist as an absence.)\n:::\n\n## More Than One Match\n\n![](images/joins_match-types.png){fig-align=\"center\"}\n\n. . . \n\nThere are three possible outcomes for a row in x:\n\n::: {.incremental}\n* If it doesn’t match anything, it’s dropped.\n* If it matches 1 row in y, it’s preserved.\n* If it matches more than 1 row in y, it’s duplicated once for each match.\n:::\n\n. . . \n\nWhat happens if we match on more than one row? \n\n## More Than One Match\n\n```{r}\n#| output-location: fragment\n#| warning: true\ndf1 <- tibble(key = c(1, 2, 2), val_x = c(\"x1\", \"x2\", \"x3\"))\ndf2 <- tibble(key = c(1, 2, 2), val_y = c(\"y1\", \"y2\", \"y3\"))\n\ndf1 |> \n  inner_join(df2, join_by(key))\n```\n\n\n. . . \n\nIf you're doing this deliberately, set relationship = \"many-to-many\", as the warning suggests.\n\n::: aside\nGiven their nature, filtering joins never duplicate rows like mutating joins do. They will only ever return a subset of the datasets.\n:::\n\n## Non-Equi Joins\n\nThe joins we've discussed thus far have all been equi-joins, where the rows match if the x key equals the y key. But you can also specify other types of relationships. \n\n. . . \n\n`dplyr` has four different types of non-equi joins: \n\n. . . \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* **Cross joins** match every pair of rows.\n:::\n\n::: {.column width=\"50%\"}\n\n![](images/joins_cross.png){width=25% .absolute top=150 right=150}\n\n:::\n::::\n\n::: aside\nCross joins, aka self-joins, are useful when generating permutations (e.g. creating every possible combination of values). This comes in handy when creating datasets of predicted probabilities for plotting in ggplot. \n:::\n\n## Non-Equi Joins\n\nThe joins we've discussed thus far have all been equi-joins, where the rows match if the x key equals the y key. But you can also specify other types of relationships. \n\n`dplyr` has four different types of non-equi joins: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* **Cross joins** match every pair of rows.\n* **Inequality joins** use <, <=, >, and >= instead of ==.\n    * **Overlap joins** are a special type of inequality join designed to work with ranges^[Overlap joins provide three helpers that use inequality joins to make it easier to work with intervals: `between()`, `within()`, `overlaps()`. Read more about their functionality and specifications [here](https://dplyr.tidyverse.org/reference/join_by.html?q=within#overlap-joins).].\n\n:::\n\n::: {.column width=\"50%\"}\n![](images/joins_inequality.png){width=30% .absolute top=158 right=120}\n:::\n::::\n\n::: aside\nInequality joins can be used to restrict the cross join so that instead of generating all permutations, we generate all combinations.\n:::\n\n## Non-Equi Joins\n\nThe joins we've discussed thus far have all been equi-joins, where the rows match if the x key equals the y key. But you can also specify other types of relationships. \n\n`dplyr` has four different types of non-equi joins: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* **Cross joins** match every pair of rows.\n* **Inequality joins** use <, <=, >, and >= instead of ==.\n    * **Overlap joins** are a special type of inequality join designed to work with ranges.\n* **Rolling joins** are similar to inequality joins but only find the closest match.\n\n:::\n\n::: {.column width=\"50%\"}\n![](images/joins_rolling.png){width=42% .absolute top=155 right=35}\n:::\n::::\n\n::: aside\nRolling joins are a special type of inequality join where instead of getting every row that satisfies the inequality, you get just the closest row. You can turn any inequality join into a rolling join by adding closest().\n:::\n\n# Tidying and Reshaping Data {.section-title background-color=\"#4B2E83\"}\n\n# {data-menu-title=\"`tidyr`\" background-image=\"images/tidyr.png\" background-size=\"contain\" background-position=\"center\" .section-title background-color=\"#B7A57A\"}\n\n## What is Tidy Data\n\n**Tidy data^[Read the original article [here](https://www.jstatsoft.org/article/view/v059i10).]** (aka \"long data\") are such that:\n\n![](images/tidy-1.png){fig-align=\"center\"}\n\n::: {.incremental}\n1. The values for a single variable are in their own column.\n2. The values for a single observation are in their own row.\n3. There is only one value per cell.\n:::\n\n## Why do we Want Tidy Data?\n\n::: {.incremental}\n* **Easier to understand** many rows than many columns^[Placing variables in columns also leverages `R`'s vectorized nature, i.e. most built-in `R` functions work with values of vectors.]\n* Required for **plotting** in `ggplot2`^[In fact, all tidyverse functions are designed to work with tidy data.]\n* Required for many types of **statistical procedures** (e.g. hierarchical or mixed effects models)\n* Fewer issues with **missing values and \"imbalanced\"** repeated measures data\n* Having a consistent method for storing data means it's easier to learn the tools to work with it since there's an underlying uniformity.\n:::\n\n. . . \n\nMost real-world data is not tidy because data are often organized for goals other than analysis (i.e. data entry) and most people aren't familiar with the principles of tidy data. \n\n## Slightly \"Messy\" Data\n\n::::{.columns}\n:::{.column width=\"60%\"}\n\n| **Program**     | **First Year** | **Second Year** |\n|-----------------|-----------:|---------:|\n| Evans School    |     10     |    6    |\n| Arts & Sciences |      5     |    6    |\n| Public Health   |      2     |    3    |\n| Other           |      5     |    1    |\n\n:::\n:::{.column width=\"40%\"}\n\n* What is an **observation**?\n    + A group of students from a program of a given year\n    \n\n* What are the **variables**?\n    + Program, Year\n\n\n* What are the **values**?\n    + Program: Evans School, Arts & Sciences, Public Health, Other\n    + Year: First, Second -- **in column headings. Bad!**\n    + Count: **spread over two columns!**\n:::\n::::\n\n## Tidy Version\n\n::::{.columns}\n:::{.column width=\"50%\"}\n\n| **Program**     | **Year** | **Count** |\n|-----------------|-----------:|---------:|\n| Evans School    |     First |    10   |\n| Evans School    |     Second   |    6    |\n| Arts & Sciences |     First |    5    |\n| Arts & Sciences |     Second   |    6    |\n| Public Health   |     First |    2    |\n| Public Health   |     Second   |    3    |\n| Other           |     First |    5    |\n| Other           |     Second   |    1    |\n:::\n:::{.column width=\"50%\"}\n* Each variable is a column.\n\n* Each observation is a row.\n\n* Each cell has a single value.\n:::\n::::\n\n## Billboard Data\n\n```{r}\n#| echo: false\nglimpse(billboard_2000_raw)\n```\n\n. . . \n\n\\\n\nThis data is just ugly-messy!\n\n::: aside\nWeek columns continue up to `wk76`!\n:::\n\n## How is Billboard currently organized?\n\n::: {.incremental}\n* What are the **observations** in the data?\n    + Song on the Billboard chart each week\n* What are the **variables** in the data?\n    + Year, artist, track, song length, date entered Hot 100, week since first entered Hot 100 (**spread over many columns**), rank during week (**spread over many columns**)\n* What are the **values** in the data?\n    + e.g. 2000; 3 Doors Down; Kryptonite; 3 minutes 53 seconds; April 8, 2000; Week 3 (**stuck in column headings**); rank 68 (**spread over many columns**)\n:::\n\n## `tidyr`\n\nThe `tidyr` package provides functions to tidy up data. \n\n. . . \n\n**Key functions:**\n\n* **`pivot_longer()`**: takes a set of columns and pivots them down (\"longer\") to make two new columns (which you can name yourself): \n    * A `name` column that stores the original column names\n    * A `value` with the values in those original columns\n\n. . . \n\n* **`pivot_wider()`**: inverts `pivot_longer()` by taking two columns and pivoting them up and across (\"wider\") into multiple columns\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n::: {.incremental}\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. `names_to`: Names the new variable that is stored in multiple columns\n3. `values_to`: Names the variable stored in the cell values\n:::\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. **`names_to`: Names the new variable that is stored in multiple columns**\n3. `values_to`: Names the variable stored in the cell values\n\n![](images/pivot_longer2_column_names.png){fig-align=\"center\"}\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. `names_to`: Names the new variable that is stored in multiple columns\n3. **`values_to`: Names the variable stored in the cell values**\n\n![](images/pivot_longer3_cell_values.png){fig-align=\"center\"}\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. `names_to`: Names the new variable that is stored in multiple columns\n3. `values_to`: Names the variable stored in the cell values\n\n![](images/pivot_longer1_variables.png){fig-align=\"center\"}\n\n## `pivot_longer()` Example\n\n```{r}\n#| output-location: fragment \nbillboard_2000 <- billboard_2000_raw |> \n  pivot_longer(cols = starts_with(\"wk\"), # <1>\n               names_to =\"week\",\n               values_to = \"rank\")\n\nbillboard_2000 |> head(10)\n```\n\n1. `starts_with()` is one of the helper functions from [`tidyselect`](https://tidyselect.r-lib.org/index.html) that helps select certain common patterns. We could have also used `cols = wk1:wk76`. \n\n. . . \n\nNow we have a single week column!\n\n## Lots of Missing Values?!\n\n```{r}\n#| output-location: fragment \nglimpse(billboard_2000)\n```\n\n::: {.fragment}\nIt looks like 2 Pac's song \"Baby Don't Cry\" was only on the Billboard Hot 100 for 7 weeks and then dropped off the charts. \n:::\n. . . \n\n```{r}\n#| output-location: fragment \nsummary(billboard_2000$rank)\n```\n\n::: {.fragment}\nWe don't want to keep the `r sum(is.na(billboard_2000$rank))` rows with missing ranks.\n:::\n\n## Pivoting Better: `values_drop_na`\n\nAdding the argument `values_drop_na = TRUE` to `pivot_longer()` will remove rows with missing ranks. Since these `NA`s don’t really represent unknown observations (i.e. they were forced to exist by the structure of the dataset) this is an appropriate approach here. \n\n```{r}\n#| output-location: fragment \n#| code-line-numbers: \"|5\"\nbillboard_2000 <- billboard_2000_raw %>%\n  pivot_longer(cols = wk1:wk76, \n               names_to = \"week\", \n               values_to = \"rank\", \n               values_drop_na = TRUE)\nsummary(billboard_2000$rank)\n```\n\n. . . \n\nNo more `NA` values!\n\n```{r}\n#| output-location: fragment \ndim(billboard_2000)\n```\n\n. . . \n\nAnd way fewer rows!\n\n## `parse_number()`\n\nThe week column is of the type `character`, but it should be `numeric.`\n\n```{r}\n#| output-location: fragment \nhead(billboard_2000$week)\n```\n\n. . . \n\n`parse_number()` grabs just the numeric information from a character string:\n\n```{r}\n#| output-location: fragment \nbillboard_2000 <- billboard_2000 |> \n    mutate(week = parse_number(week)) # <2>\nsummary(billboard_2000$week)\n```\n2. You can use `mutate()` to overwrite existing columns. \n\n## Use `pivot_longer` arguments\n\nAlternatively (and more efficiently), there are a number of optional arguments for `pivot_longer` that are meant to help deal with naming issues.\n\n. . . \n\n```{r}\n#| output-location: fragment\nbillboard_2000 <- billboard_2000_raw %>%\n  pivot_longer(starts_with(\"wk\"), \n               names_to        = \"week\", \n               values_to       = \"rank\",\n               values_drop_na  = TRUE,\n               names_prefix    = \"wk\", # <3>\n               names_transform = list(week = as.integer)) # <4>\n\nhead(billboard_2000, 5)\n```\n\n3. `names_prefix` is used to remove \"wk\" from the values of `week`\n4. `names_transform` converts `week` into an integer number.\n\n## Multiple Variables in Column Names\n\nA more challenging situation occurs when you have multiple pieces of information crammed into the column names, and you would like to store these in separate new variables.\n\n. . . \n\nThis dataset contains tuberculosis diagnoses collected by the World Health Organization. \n\n```{r}\n#| output-location: fragment\nwho2\n```\n\n. . . \n\nThe first two columns are self explanatory but what's going on with the rest?\n\n## Multiple Variables in Column Names\n\nData documentation and some minor investigation would lead you to figure out that the three elements in each of these column names are actually data!\n\n* The first piece, `sp`/`sn`/`rel`/`ep`, describes the method used for the diagnosis\n* The second piece, `m`/`f` is the gender (coded as a binary variable in this dataset)\n* The third piece, `014`/`1524`/`2534`/`3544`/`4554`/`5564`/`65` is the age range (014 represents 0-14, for example)\n\n. . . \n\nTo organize the six pieces of information in this dataset into six separate columns, we use `pivot_longer()` with a vector of column names for `names_to` and instructors for splitting the original variable names into pieces for `names_sep` as well as a column name for `values_to`!\n\n## Multiple Variables in Column Names\n\n```{r}\n#| output-location: fragment\nwho2 |> \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\", # <5>\n    values_to = \"count\"\n  )\n```\n\n5. You can use `names_pattern` instead of `names_sep` to extract variables from more complicated naming scenarios if you are familiar with regular expressions. \n\n## Variable & Values in Column Names\n\nThis dataset contains data about five families, with the names and dates of birth of up to two children. \n\n```{r}\n#| output-location: fragment\nhousehold\n```\n\n. . . \n\nThe new challenge in this dataset is that the column names contain the names of two variables (`dob`, `name`) and the values of another (`child`, with values `1` or `2`).\n\n## Variable & Values in Column Names\n\n```{r}\n#| output-location: column-fragment\nhousehold |> \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), # <6>\n    names_sep = \"_\", \n    values_drop_na = TRUE # <7> \n  )\n```\n\n6. `.value` isn’t the name of a variable but a unique value that tells `pivot_longer` to use the first component of the pivoted column name as a variable name in the output. \n7. Using `values_drop_na = TRUE` again since not every family has 2 children.\n\n. . . \n\n![](images/pivot_longer5_names-and-values.png){width=75% fig-align=\"center\"}\n\n## `pivot_wider`\n\n`pivot_wider()` is the opposite of `pivot_longer()`, which you use if you have data for the same observation taking up multiple rows.\n\n. . . \n\nHere's an example of data that we probably want to pivot wider (unless we want to plot each statistic in its own facet):\n\n```{r}\n#| echo: false\nlong_stats <- tibble(Group = c(rep(\"A\", 3), rep(\"B\", 3)),\n                     Statistic = rep(c(\"Mean\", \"Median\", \"SD\"), 2),\n                     Value = c(1.28, 1.0, 0.72, 2.81, 2, 1.33))\nlong_stats\n```\n\n. . . \n\nA common cue to use `pivot_wider()` is having measurements of different quantities in the same column.\n\n## `pivot_wider` Example \n\n```{r}\n#| output-location: fragment\nwide_stats <- long_stats |> \n  pivot_wider(id_cols = Group, # <8>\n              names_from = Statistic, # <9>\n              values_from = Value) # <10>\nwide_stats\n```\n\n8. `id_cols` is the column that uniquely identifies each row in the new dataset. Default is everything not in `names_from` and `values_from`.\n9. `names_from` provides the names that will be used for the new columns\n10. `values_from` provides the values that will be used to populate the cells of the new columns.\n\n. . . \n\n[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.html) also has a number of optional `names_*` and `values_*` arguments for more complicated transformations. \n\n. . . \n\n::: {.callout-warning icon=false}\n## <span style=\"color:orange\">{{< fa triangle-exclamation >}}</span> Nested Data\nIf there are multiple rows in the input that correspond to one cell in the output you'll get a list-column. This means that you 1) need to fix something in your code/data because it shouldn't be nested in this way or 2) need to use `unnest_wider()` or `unnest_longer()` in order to access this column of data. More on this [here](https://r4ds.hadley.nz/rectangling.html#unnesting). \n:::\n\n## Useful Resources\n\n. . . \n\n**Cheatsheets:**\n\n* [readr](https://rstudio.github.io/cheatsheets/data-import.pdf)\n* [dplyr](https://rstudio.github.io/cheatsheets/data-transformation.pdf)\n* [tidyr](https://rstudio.github.io/cheatsheets/tidyr.pdf)\n\n\n**Introductory Book:**\n\n[R for Data Science (2e)](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund\n\n# {data-menu-title=\"R Knowledge Comic\" .section-title background-image=\"images/r_knowledge.png\"}\n\n## CSSCR Consulting Services\n\nCSSCR is a resource center for the social science departments^[Constituent member departments include The College of Education, The Department of Anthropology, The Department of Communication, The Department of Economics, The Department of Geography, The Department of Political Science, The Department of Psychology, The Department of Sociology, The Jackson School of International Studies, and The School of Social Work] at the University of Washington.\n\n. . . \n\nAs you continue to learn `R` feel free to drop by with any/all of your `R` coding questions. Below are our hours for the quarter: \n\n```{r}\n#| echo: false\nlibrary(gt)\nhours <- tibble(day = c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"), \n                drop_in = c(rep(\"8am - 6pm\", 4), \"8am - 5pm\"), \n                evening = c(rep(\"6 - 9pm\", 4), \"\"))\n\nhours |> \n  gt(rowname_col = \"day\") |> \n  tab_header(title = \"The Center for Social Science Computation and Research\", \n             subtitle = \"Consulting Hours for Fall 2024\")  |> \n  cols_label(drop_in = \"In-Person\", \n             evening = \"Virtual\") |> \n  tab_footnote(footnote = \"Drop-in @ Savery 119\", \n               locations = cells_column_labels(columns = drop_in), \n               placement = \"right\") |> \n  tab_footnote(footnote = \"Online Via Zoom\", \n               locations = cells_column_labels(columns = evening), \n               placement = \"right\") |> \n  tab_options(footnotes.multiline = FALSE) |> \n  data_color(columns = drop_in, \n             palette = c(\"LightGoldenrodYellow\", \"PaleGoldenrod\")) |> \n  data_color(columns = evening, \n             palette = \"Purples\")\n\n```\n\n\n# Thanks!{.section-title background-color=\"#4B2E83\"}\n\n","srcMarkdownNoYaml":"\n\n```{r}\n#| echo: false\n#| cache: false\nrequire(downlit)\nrequire(xml2)\nrequire(tidyverse)\nlibrary(gapminder)\nlibrary(nycflights13)\n#options(width = 90)\n```\n\n## {#title-slide data-menu-title=\"Data Wrangling in R\" background-image=\"images/rainier.png\" background-size=\"cover\" background-color=\"#4B2E83\"}\n\n[Data Wrangling in R]{.custom-title}\n\n[CSSCR Workshop]{.custom-subtitle}\n\n[31 October 2024]{.custom-subtitle2}\n\n[Victoria Sass]{.custom-subtitle3}\n\n## Roadmap\n\n::: {.incremental}\n* Importing and Exporting Data\n* Manipulating and Summarizing Data \n* Merging Data\n* Tidying and Reshaping Data\n:::\n\n# Importing and Exporting Data{.section-title background-color=\"#4B2E83\"}\n\n## Data Packages\n\nR has a *big* user base.  If you are working with a popular data source, it will often have a devoted R package on *CRAN* or *Github*. \n\n. . . \n\nExamples:\n\n* [`WDI`](https://vincentarelbundock.github.io/WDI/): World Development Indicators (World Bank)\n* [`tidycensus`](https://walker-data.com/tidycensus/): Census and American Community Survey\n* [`quantmod`](https://walker-data.com/tidycensus/): financial data from Yahoo, FRED, Google\n* [`gssr`](https://kjhealy.github.io/gssr/): The General Social Survey Cumulative Data (1972-2021)\n* [`psidR`](https://github.com/floswald/psidR): Panel Study of Income Dynamics (basic & public datasets)\n\n. . . \n\nIf you have an actual data file, you'll have to import it yourself...\n\n## Delimited Text Files\n\nBesides a package, it's easiest when data is stored in a text file. The most commonly encountered delimited file is a **.csv**.\n\n. . . \n\nA comma-separated values (.csv) file looks like the following: \n\n```\n\"Subject\",\"Depression\",\"Sex\",\"Week\",\"HamD\",\"Imipramine\"\n101,\"Non-endogenous\",\"Second\",0,26,NA\n101,\"Non-endogenous\",\"Second\",1,22,NA\n101,\"Non-endogenous\",\"Second\",2,18,4.04305\n101,\"Non-endogenous\",\"Second\",3,7,3.93183\n101,\"Non-endogenous\",\"Second\",4,4,4.33073\n101,\"Non-endogenous\",\"Second\",5,3,4.36945\n103,\"Non-endogenous\",\"First\",0,33,NA\n103,\"Non-endogenous\",\"First\",1,24,NA\n103,\"Non-endogenous\",\"First\",2,15,2.77259\n```\n\n# {data-menu-title=\"`readr``\" background-image=\"images/readr.png\" background-size=\"contain\" background-position=\"center\" .section-title background-color=\"#B7A57A\"}\n\n## `readr`\n\nR has some built-in functions for importing data, such as `read.table()` and `read.csv()`. \n\n. . . \n\nThe `readr` package provides similar functions, like `read_csv()`, that have slightly better features:\n\n::: {.incremental}\n* Faster!\n* Better defaults (e.g. doesn't automatically convert characters to factors)\n* A *bit* smarter about dates and times\n* Loading progress bars for large files\n:::\n\n. . . \n\n`readr` is one of the core `tidyverse` packages so loading `tidyverse` will load it too:\n\n```{r}\nlibrary(tidyverse)\n```\n\n. . . \n\nAlternatively, you can just load `readr` like so:\n\n```{r}\n#| eval: false\nlibrary(readr)\n```\n\n## `readr` Importing Example\n\nLet's import some data about song ranks on the Billboard Hot 100 in 2000:\n\n```{r}\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\")\n```\n\n. . . \n\nHow do we know it loaded? \n\n. . . \n\nLet's look at it!\n\n```{r}\n#| output-location: fragment\nglimpse(billboard_2000_raw)\n```\n\n## Alternate Solution\n\nWhen you import data from an external file you'll also see it in the Global Environment tab in the upper-right pane of RStudio: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n::: {.fragment}\nYou can also import the data manually!\n\nIn the upper right-hand pane of RStudio (make sure you're in the Environment tab), select:\n\n`Import Dataset > From Text (readr)` and browse to the file on your computer^[Ideally you've saved it in your project folder!].\n:::\n\n::: {.fragment}\n**Once you've imported the data, you can `copy/paste` the import code from the console into your file!!**\n\nThis makes the process *reproducible!*\n:::\n:::\n::: {.column width=\"50%\"}\n![](images/data_global_env.png)\n\n:::\n\n::::\n\n## Manual Data Import\n\n![](images/data_import_manual.png){fig-align=\"center\"}\n\n## Specifying `NA`s \n\nSometimes a particular dataset or file read from a different software will code `NA`s differently than `R`. If that's the case, you can add additional specifications to `read_csv` for what to read in as `NA`.  \n\n\n```{r}\n#| eval: false\n#| code-line-numbers: \"|2\"\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               na = c(\"N/A\", \"999\"))\n```\n\n## Skipping lines\n\nDepending on how the data were input, there may be several lines that precede the beginning of the data table you're interested in importing. You can skip these lines of metadata with the `skip` argument:\n\n```{r}\n#| eval: false\n#| code-line-numbers: \"|2\"\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               skip = 1)\n```\n\n## Variable names\n\n`read_csv` will automatically take the first row as column names. If you want to rename them you can save yourself some time recoding later on if you specify your preferred variable names upfront with the `col_names` argument. \n\n. . . \n\nIt takes a character vector to be used as column names (in their order of appearance). \n\n```{r}\nbillboard_renamed <- read_csv(file = \"data/billboard.csv\",\n                              col_names = c(\"year\", \"artist\", \"track\", \"time\", \"date_entered\", \n                                            paste(\"wk\", 1:76, sep = \"_\"))) # <1>\n\nbillboard_renamed |>  names() |> head(10) # <2>\n```\n1. First few entries: \"wk_1\"  \"wk_2\"  \"wk_3\"\n2. `names` returns the column names.\n\n. . . \n\nIf you don't have any variable names you can specify that instead. \n\n```{r}\n#| eval: false\n#| code-line-numbers: \"|2\"\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_names = FALSE) \n```\n\n## Snake Case\n\nIf you simply want to change your variables to snake case (all lower case; words separated by `_`), you can use the function `clean_names()` from the `janitor` package which replaces other punctuation separators with `_`. \n\n```{r}\n#| output-location: fragment\n# Download package first\n# install.packages(\"janitor\") # <3> \n\n# Create new object for renamed data\nbillboard_renamed <- billboard_2000_raw |> \n  janitor::clean_names(numerals = \"right\") # <4>\n\nbillboard_renamed |>  names() |> head(10)\n```\n\n3. Run in the console first. \n4. You can call a function without loading its package by specifying its package name followed by `::` before it; <br> The `numerals` argument specifies if you additionally want to put a separator before a number. \n\n## Other Data File Types with `readr`\n\nThe other functions in `readr` employ a similar approach to `read_csv` so the trick is just knowing which to use for what data type. \n\n. . . \n\n* `read_csv2` is separated by semicolons (instead of commas)\n* `read_tsv` is separated by tabs\n* `read_delim` guesses the delimiter\n* `read_fwf` reads in fixed-width-files\n* `read_table` is a variation of `fwf` where columns are separated by white space\n* `read_log` reads in Apache-style log files\n\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](images/readxl.png){.absolute top=185 left=135}\n:::\n::: {.column width=\"50%\"}\n* For Excel files (`.xls` or `.xlsx`), use package [`readxl`](https://readxl.tidyverse.org/)^[Functions have additional arguments to read in specific sheets or a range of cells.]\n:::\n::::\n\n::: aside\nNote: For Excel files and Googlesheets You **won't** keep text formatting, color, comments, or merged cells. See the [`openxlsx`](https://ycphs.github.io/openxlsx/) package for those capabilities. Also, [`tidyxl`](https://github.com/nacnudus/tidyxl) can help import non-tabular data from Excel. \n:::\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](images/googlesheets4.png){.absolute top=185 left=135}\n:::\n::: {.column width=\"50%\"}\n* For Excel files (`.xls` or `.xlsx`), use package [`readxl`](https://readxl.tidyverse.org/)^[Functions have additional arguments to read in specific sheets or a range of cells.]\n* For Google Docs Spreadsheets, use package [`googlesheets4`](https://googlesheets4.tidyverse.org/)^[Very similar to `readxl` with some slight variations you can read about [here](https://r4ds.hadley.nz/spreadsheets.html#google-sheets).]\n:::\n::::\n\n::: aside\nNote: For Excel files and Googlesheets You **won't** keep text formatting, color, comments, or merged cells. See the [`openxlsx`](https://ycphs.github.io/openxlsx/) package for those capabilities. Also, [`tidyxl`](https://github.com/nacnudus/tidyxl) can help import non-tabular data from Excel. \n:::\n\n## Other Packages to Read in Data\n\nThere are a range of other ways, besides delimited files, that data are stored. \n\nThe following packages are part of the extended `tidyverse` and therefore operate with similar syntax and logic as `readr`.\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](images/haven.png){.absolute top=185 left=135}\n:::\n::: {.column width=\"50%\"}\n* For Excel files (`.xls` or `.xlsx`), use package [`readxl`](https://readxl.tidyverse.org/)^[Functions have additional arguments to read in specific sheets or a range of cells.]\n* For Google Docs Spreadsheets, use package [`googlesheets4`](https://googlesheets4.tidyverse.org/)^[Very similar to `readxl` with some slight variations you can read about [here](https://r4ds.hadley.nz/spreadsheets.html#google-sheets).]\n* For Stata, SPSS, and SAS files, use package [`haven`](https://haven.tidyverse.org/)^[SAS, SPSS, and Stata have so-called \"labelled\" vectors for which `haven` provides a [class](https://haven.tidyverse.org/reference/index.html#labelled-vectors) to represent in `R`. Alternatively, you can get rid of them with [these functions](https://haven.tidyverse.org/reference/index.html#remove-attributes).]\n:::\n::::\n\n::: aside\nNote: For Excel files and Googlesheets You **won't** keep text formatting, color, comments, or merged cells. See the [`openxlsx`](https://ycphs.github.io/openxlsx/) package for those capabilities. Also, [`tidyxl`](https://github.com/nacnudus/tidyxl) can help import non-tabular data from Excel. \n:::\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks: \n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#B7A57A,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#B7A57A,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id5 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#B7A57A,color:#000000,stroke:#000000\n    style D fill:#FFFFFF,color:#000000,stroke:#000000\n\n```\n\n## How does `readr` parse different data types?\n\nFor each column in a data frame, `readr` functions pull the first 1000 rows and checks:\n\n```{mermaid}\n%%| echo: false\n%%| fig-width: 11\n%%| fig-height: 5.5\n%%| fig-align: center\nflowchart LR\n    id1((Variable))==>A([\"1. Does it contain only F, T, FALSE, TRUE, or NA (ignoring case)?\"])==>id2{{Logical}}\n    id1((Variable))==>B([\"2. Does it contain only numbers (e.g., 1, -4.5, 5e6, Inf?)\"])==>id3{{Number}}\n    id1((Variable))==>C([\"3. Does it match the ISO8601 standard?\"])==>id4{{Date/Date-time}}\n    id1((Variable))==>D([\"4. None of the above\"])==>id5{{String}}\n    style id1 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style id2 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id3 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id4 fill:#B7A57A,color:#4B2E83,stroke:#4B2E83\n    style id5 fill:#4B2E83,color:#B7A57A,stroke:#B7A57A\n    style A fill:#FFFFFF,color:#000000,stroke:#000000\n    style B fill:#FFFFFF,color:#000000,stroke:#000000\n    style C fill:#FFFFFF,color:#000000,stroke:#000000\n    style D fill:#B7A57A,color:#000000,stroke:#000000\n\n```\n\n## Most Common Issue with Reading in Data\n\nThe most common problem that occurs when reading in data is having mixed data. Most often, given the heuristic provided in the last slide, `R` will parse a variable as a character string to preserve whatever it contains. \n\n. . . \n\nLet's actually look at how the billboard data was read in: \n\n```{r}\n#| output-location: fragment\nglimpse(billboard_2000_raw) \n```\n\n## What Went Wrong? \n\nSince `readr` uses the values in the first 1000 rows to guess the type of the column (logical, numeric, date/date-time, character), if the first 1000 rows don't have any data, they will be coded as logical variables. \n\n. . . \n\nThere are not many songs in the data that charted for 60+ weeks—and none in the first 1000 that charted for 66+ weeks!\n\n. . . \n\n::: {.callout-note icon=false}\n\n## <span style=\"color:blue\">{{< fa circle-info >}}</span> \\ `NA` is logical?\n\n```{r}\n#| output-location: fragment\nclass(c(T, F, NA, FALSE, TRUE))\nclass(c(1, NA, 17.5, 5.3, NA)) # <5>\nclass(as.Date(c(NA, \"2023-10-31\", \"1986-06-21\", \"1997-01-15\"), tz = \"America/Los_Angeles\")) # <6>\nclass(c(\"apple\", NA, \"mango\", \"blackberry\", \"plum\")) \nclass(c(NA, NA, NA, NA, NA))\n```\n\n5. `class` returns the data type of its first argument. \n6. `as.Date` turns a character string of dates into an official date class in Base `R`. If we had an accompanying time stamp we would need to use `as.POSIXct` which turns a character string of dates and times into an official date-time class in Base `R`. \n:::\n\n::: aside\nTechnically, `NA`s can be any data type depending upon what they are grouped with. However, by themselves they are a logical indicator of missing data, so their class is logical. \n:::\n\n## Column types\n\nSince the `wk*` variables should all be read in as integers, we can specify this explicitly with the `col_types` argument. \n\n. . . \n\n```{r}\n#| output-location: fragment\n# Create character string of shortcode column types\nbb_types <- paste(c(\"icctD\", rep(\"i\", 76)), collapse=\"\") # <7>\nbb_types \n```\n\n7. You can short-code column types with `i` = integer, `c` = character, `t` = time, `D` = date. <br> The `collapse` argument collapses the first two arguments into one complete character string.\n\n. . . \n\n<br>\n\n```{r}\n# re-read in data with column types specified\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_types = bb_types) # <8>\n```\n8. See all column types and short codes [here](https://readr.tidyverse.org/reference/cols.html).\n\n## Column types\n\nTo specify a default column type you can use `.default` like so: \n\n```{r}\n#| eval: false\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_types = cols(.default = col_character())) \n```\n\n. . . \n\n<br>\n\nAnother useful helper is `cols_only()` for when you only want to read in a subset of all available variables.\n\n```{r}\n#| eval: false\nbillboard_2000_raw <- read_csv(file = \"data/billboard.csv\", \n                               col_types = cols_only(x = col_character)) \n```\n\n. . . \n\n<br>\n\nIn summary, the `col_types` argument gives you greater control over how your data are read in and can save you recoding time down the road and/or point out where your data are behaving differently than you expect. \n\n## Writing Delimited Files\n\nGetting data out of R into a delimited file is very similar to getting it into R:\n\n```{r}\n#| eval: false\nwrite_csv(billboard_2000_raw, path = \"data/billboard_data.csv\")\n```\n\nThis saved the data we pulled off the web in a file called `billboard_data.csv` in the `data` folder of my working directory.\n\n. . . \n\nHowever, saving data in this way will not preserve `R` data types since delimited files code everything as a character string. \n\n. . . \n\nTo save `R` objects and all associated metadata you have two options: \n\n::: {.panel-tabset}\n\n### `.Rds` format:\n\n* Used for single objects, doesn't save the original object name\n* Save: `write_rds(old_object_name, \"path.Rds\")`\n* Load: `new_object_name <- read_rds(\"path.Rds\")`\n\n### `.Rdata` or `.Rda` format:\n\n* Used for saving multiple files where the original object names are preserved\n* Save: `save(object1, object2, ... , file = \"path.Rdata\")`\n* Load: `load(\"path.Rdata\")` without assignment operator\n\n:::\n\n## Writing Other File-Types\n\n::: {.panel-tabset}\n\n### `writexl`\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n* `write_xlsx()` writes to an xlsx file\n:::\n\n::: {.column width=\"40%\"}\n![](images/writexl.png){width=50%}\n:::\n\n::::\n\n### `googlesheets4`\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n* `sheet_write()` or `write_sheet()` (over)writes new data into a Sheet\n* `gs4_create()` creates a new Sheet\n* `sheet_append()` appends rows to a sheet\n* `range_write()` (over)writes new data into a range\n* `range_flood()` floods a range of cells\n* ``range_clear()` clears a range of cells\n:::\n\n::: {.column width=\"40%\"}\n![](images/googlesheets4.png){width=50%}\n:::\n\n::::\n\n### `haven`\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n* `write_dta()` writes Stata DTA files\n* `write_sav()` writes SPSS files\n* `write_xpt()` writes SAS transport files\n:::\n\n::: {.column width=\"40%\"}\n![](images/haven.png){width=50%}\n:::\n\n::::\n\n:::\n\n# Manipulating and Summarizing Data{.section-title background-color=\"#4B2E83\"}\n\n## Death to Spreadsheets\n\nTools like *Excel* or *Google Sheets* let you manipulate spreadsheets using functions.\n\n::: {.incremental}\n* Spreadsheets are *not reproducible*: It's hard to know how someone changed the raw data!\n* It's hard to catch mistakes when you use spreadsheets^[Don't be the next sad Research Assistant who makes headlines with an Excel error! ([Reinhart & Rogoff, 2010](http://www.bloomberg.com/news/articles/2013-04-18/faq-reinhart-rogoff-and-the-excel-error-that-changed-history))].\n:::\n \n. . .  \n \nWe want to know how to use `R` to manipulate data more *transparently* and *reproducibly*.\n\n# Logical Operators{.section-title background-color=\"#B7A57A\"}\n\n## Data types in `R`\n\nThere are a variety of data types in `R`: \n\n. . . \n\n* Factors\n* Date/Date-time\n* Logical\n* Numeric\n* Missing Values\n* Strings\n\n## Data types in `R`\n\nThere are a variety of data types in `R`: \n\n* Factors\n* Date/Date-time\n* <span style=\"color:#e15759\">Logical</span>\n* Numeric\n* Missing Values\n* Strings\n\n## Logical Operators in `R`\n  \n#### Comparing objects\n:::: {.columns}\n\n::: {.column width=\"19%\"}\n::: {.fragment}\n* `==`: \n* `!=`: \n* `>`, `>=`, `<`, `<=`: \n* `%in%`: \n:::\n:::\n\n::: {.column width=\"81%\"}\n\n::: {.fragment}\n* is equal to^[Note: there are TWO equal signs here!]\n* not equal to\n* less than, less than or equal to, etc.\n* used when checking if equal to one of several values\n:::\n:::\n\n::::\n\n:::{.fragment}\n#### Combining comparisons\n:::\n\n:::: {.columns}\n\n::: {.column width=\"19%\"}\n::: {.fragment}\n* `&`: \n* `|`: \n* `!`: \n* `xor()`:\n:::\n:::\n\n::: {.column width=\"81%\"}\n\n::: {.fragment .bullet-spacing}\n* **both** conditions need to hold (AND)\\\n* **at least one** condition needs to hold (OR)\\\n* **inverts** a logical condition (`TRUE` becomes `FALSE`, vice versa)\\\n* **exclusive OR** (i.e. x or y but NOT both)\n:::\n:::\n\n::::\n\n::: aside\nYou may also see `&&` and `||` but they are what's known as short-circuiting operators and are not to be used in `dplyr` functions (used for programming not data manipulation); they'll only ever return a single `TRUE` or `FALSE`.\n:::\n\n## Logical Summaries\n\n:::: {.columns}\n\n::: {.column width=\"19%\"}\n::: {.fragment}\n* `any()`: \n* `all()`: \n:::\n:::\n\n::: {.column width=\"81%\"}\n\n::: {.fragment}\n* the equivalent of `|`; it’ll return `TRUE` if there are any `TRUE`’s in x\n* the equivalent of `&`; it’ll return `TRUE` only if all values of x are `TRUE`’s\n:::\n:::\n\n::::\n\n. . .\n\n```{r}\nC <- c(5, 10, NA, 10, 20, NA)\nany(C <= 10) \nall(C <= 20) # <1> \nall(C <= 20, na.rm = TRUE) # <2>\nmean(C, na.rm = TRUE) # <3> \n\n```\n1. Like other summary functions, they'll return `NA` if there are any missing values present and it's `FALSE`. \n2. Use `na.rm = TRUE` to remove `NA`s prior to evaluation. \n3. When you evaluate a logical vector numerically, `TRUE` = 1 and `FALSE` = 0. This makes `sum()` and `mean()` useful when summarizing logical functions (sum gives number of `TRUE`s and mean gives the proportion). \n\n## Conditional transformations\n\n<ins>**`if_else()`**</ins>\n\nIf you want to use one value when a condition is `TRUE` and another value when it’s `FALSE`.\n\n. . . \n\n```{r}\n#| eval: false\nif_else(condition = \"A logical vector\", \n        true = \"Output when condition is true\", \n        false = \"Output when condition is false\")\n```\n\n. . . \n\n```{r}\nx <- c(-3:3, NA)\nif_else(x > 0, \"+ve\", \"-ve\", \"???\") # <4> \n```\n4. There’s an optional fourth argument, `missing` which will be used if the input is `NA`.\n\n. . . \n\n<ins>**`case_when()`**</ins>\n\nA very useful extension of `if_else()` for multiple conditions^[Note that if multiple conditions match in `case_when()`, only the first will be used. \n]. \n\n. . . \n\n```{r}\ncase_when(\n  x == 0   ~ \"0\",\n  x < 0    ~ \"-ve\", \n  x > 0    ~ \"+ve\",\n  is.na(x) ~ \"???\" # <5>\n) # <6> \n```\n\n5. Use `.default` if you want to create a “default”/catch all value. \n6. Both functions require compatible types: i.e. numerical and logical, strings and factors, dates and datetimes, `NA` and everything. \n\n# {data-menu-title=\"`dplyr`\" background-image=\"images/dplyr.png\" background-size=\"contain\" background-position=\"center\" .section-title background-color=\"#B7A57A\"}\n\n## `dplyr`\n\nToday, we'll use tools from the `dplyr` package to manipulate data! \n\n* `dplyr` is part of the *Tidyverse*, and included in the `tidyverse` package. \n\n```{r}\nlibrary(tidyverse)\n```\n\n. . . \n\nTo demonstrate data transformations we're going to use the `nycflights13` dataset, which you'll need to download and load into `R`\n\n```{r}\n# Download and load data\n# install.packages(\"nycflights13\") # <7>\nlibrary(nycflights13) # <8>\n```\n\n7. Run in console. \n8. Load into `R` session. \n\n. . . \n\n`nycflights13` includes five dataframes^[Note these are separate data frames, each needing to be loaded separately:], some of which contain missing data (`NA`):\n\n```{r}\n#| eval: false\ndata(flights) # <9> \ndata(airlines) # <10>\ndata(airports) # <11>\ndata(planes) # <12>\ndata(weather) # <13>\n```\n\n9. flights leaving JFK, LGA, or EWR in 2013\n10. airline abbreviations\n11. airport metadata\n12. airplane metadata\n13. hourly weather data for JFK, LGA, and EWR\n\n## `dplyr` Basics\n\nAll `dplyr` functions have the following in common: \n\n::: {.incremental}\n1. The first argument is always a data frame.\n2. The subsequent arguments typically describe which columns to operate on, using the variable names (without quotes).\n3. The output is always a new data frame.\n:::\n\n. . . \n\nEach function operates either on rows, columns, groups, or entire tables.\n\n. . . \n\nTo save the transformations you've made to a data frame you'll need to save the output to a new object. \n\n# Subsetting data{.section-title background-color=\"#B7A57A\"}\n\n## Subset Rows: `filter()`\n\nWe often get *big* datasets, and we only want some of the entries. We can subset rows using `filter()`.\n\n. . . \n\n```{r}\ndelay_2hr <- flights |> \n  filter(dep_delay > 120) # <14>\ndelay_2hr # <15>\n```\n\n14. Here's where we'll use a lot of logical operators. Make sure to use `==` not `=` to test the logical condition. \n15. Now, `delay_2hr` is an object in our environment which contains rows corresponding to flights that experienced at least a 2 hour delay.\n\n## Subset Columns: `select()`\n\nWhat if we want to keep every observation, but only use certain variables? Use `select()`!\n\n. . . \n\nWe can select columns by name: \n\n```{r}\nflights |> \n  select(year, month, day) # <16>\n```\n\n16. You can use a `-` before a variable name or a vector of variables to drop them from the data (i.e. <br> `select(-c(year, month, day))`).\n\n## Subset Columns: `select()`\n\nWhat if we want to keep every observation, but only use certain variables? Use `select()`!\n\n\nWe can select columns between variables (inclusive): \n\n```{r}\nflights |> \n  select(year:day) # <17>\n```\n\n17. Add a `!` before `year` and you'll drop this group of variables from the data. \n\n## Subset Columns: `select()`\n\nWhat if we want to keep every observation, but only use certain variables? Use `select()`!\n\nWe can select columns based on a condition: \n\n```{r}\nflights |> \n  select(where(is.character)) # <18>\n```\n\n18. There are a number of helper functions you can use with `select()` including `starts_with()`, `ends_with()`, `contains()` and `num_range()`. Read more about these and more [here](https://tidyselect.r-lib.org/reference/index.html). \n\n## Finding Unique Rows: `distinct()`\n\nYou may want to find the unique combinations of variables in a dataset.  Use `distinct()`\n\n. . . \n\n```{r}\nflights |> \n  distinct(origin, dest) # <19>\n```\n\n19. Find all unique origin and destination pairs.\n\n## `distinct()` drops variables!\n\nBy default, `distinct()` drops unused variables. If you don't want to drop them, add the argument `.keep_all = TRUE`:\n\n. . . \n\n```{r}\nflights |> \n  distinct(origin, dest, .keep_all = TRUE) # <20> \n```\n\n20. It’s not a coincidence that all of these distinct flights are on January 1: `distinct()` will find the first occurrence of a unique row in the dataset and discard the rest. Use `count()` if you're looking for the number of occurrences. \n\n## Count Unique Rows: `count()` \n\n. . . \n\n```{r}\nflights |>\n  count(origin, dest, sort = TRUE) # <21>\n```\n\n21. `sort = TRUE` arranges them in descending order of number of occurrences. \n\n# Modifying data{.section-title background-color=\"#B7A57A\"}\n\n## Sorting Data by Rows: `arrange()`\n\nSometimes it's useful to sort rows in your data, in ascending (low to high) or descending (high to low) order. We do that with `arrange()`.\n\n. . . \n\n```{r}\nflights |> \n  arrange(year, month, day, dep_time) # <22> \n```\n\n22. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns.\n\n## Sorting Data by Rows: `arrange()`\n\nTo sort in descending order, using `desc()` within `arrange()`\n\n. . . \n\n```{r}\nflights |> \n  arrange(desc(dep_delay))\n```\n\n## Rename Variables: `rename()`\n\nYou may receive data with unintuitive variable names. Change them using `rename()`.\n\n. . . \n\n```{r}\nflights |> \n  rename(tail_num = tailnum) # <23>\n```\n\n23. `rename(new_name = old_name)` is the format. You can use `janitor::clean_names()` if you want to automate this process for a lot of variables. \n\n. . . \n\n::: {.callout-caution icon=false}\n## <span style=\"color:tomato\">{{< fa exclamation-triangle >}}</span> Variable Syntax\nI recommend **against** using spaces in a name! It makes things *really hard* sometimes!!\n:::\n\n## Create New Columns: `mutate()`\n\nYou can add new columns to a data frame using `mutate()`. \n\n. . . \n\n```{r}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    speed = distance / air_time * 60,\n    .before = 1 # <24> \n  )\n```\n\n24. By default, `mutate()` adds new columns on the right hand side of your dataset, which makes it difficult to see if anything happened. You can use the `.before` argument to specify which numeric index (or variable name) to move the newly created variable to. `.after` is an alternative argument for this.   \n\n## Specifying Variables to Keep: `mutate()`\n\nYou can specify which columns to keep with the `.keep` argument:\n\n```{r}\nflights |> \n  mutate(\n    gain = dep_delay - arr_delay,\n    hours = air_time / 60,\n    gain_per_hour = gain / hours,\n    .keep = \"used\" # <25> \n  )\n```\n\n25. \"used\" retains only the variables used to create the new variables, which is useful for checking your work. Other options include: \"all,\" \"unused,\" and \"none.\"\n\n## Move Variables Around: `relocate()`\n\nYou might want to collect related variables together or move important variables to the front. Use `relocate()`!\n\n```{r}\nflights |> \n  relocate(time_hour, air_time) # <26>\n```\n\n26. By default `relocate()` moves variables to the front but you can also specify where to put them using the `.before` and `.after` arguments, just like in `mutate()`.\n\n# Summarizing data{.section-title background-color=\"#B7A57A\"}\n\n## Grouping Data: `group_by()`\n\nIf you want to analyze your data by specific groupings, use `group_by()`:\n\n```{r}\nflights |> \n  group_by(month) # <27>\n```\n\n27. `group_by()` doesn’t change the data but you’ll notice that the output indicates that it is “grouped by” month `(Groups: month [12])`. This means subsequent operations will now work “by month”.\n\n## Summarizing Data: `summarize()`\n\n**`summarize()`** calculates summaries of variables in your data:\n\n::: {.incremental}\n* Count the number of rows\n* Calculate the mean\n* Calculate the sum\n* Find the minimum or maximum value\n:::\n\n. . . \n\nYou can use any function inside `summarize()` that aggregates *multiple values* into a *single value* (like `sd()`, `mean()`, or `max()`).\n\n## `summarize()` Example\n\nLet's see what this looks like in our flights dataset:\n\n. . . \n\n```{r}\nflights |> \n  summarize(\n    avg_delay = mean(dep_delay) # <28> \n  )\n```\n\n28. The `NA` produced here is a result of calling `mean` on `dep_delay`. Any summarizing function will return `NA` if **any** of the values are `NA`. We can set `na.rm = TRUE` to change this behavior. \n\n## `summarize()` Example\n\nLet's see what this looks like in our flights dataset:\n\n```{r}\nflights |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE) \n  )\n```\n\n## Summarizing Data by Groups\n\nWhat if we want to summarize data by our groups? Use `group_by()` **and** `summarize()`\n\n. . . \n\n```{r}\nflights |> \n  group_by(month) |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE)\n  )\n```\n\n. . . \n\nBecause we did `group_by()` with `month`, then used `summarize()`, we get *one row per value of `month`*!\n\n## Summarizing Data by Groups\n\nYou can create any number of summaries in a single call to summarize().\n\n```{r}\nflights |> \n  group_by(month) |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n() # <29>\n  )\n```\n\n29. `n()` returns the number of rows in each group. \n\n## Grouping by Multiple Variables <span style=\"color:#B7A57A\">{{< fa scroll >}}</span> {.scrollable} \n\n```{r}\ndaily <- flights |> \n  group_by(year, month, day)  \ndaily\n```\n\n. . . \n\n::: {.callout-tip icon=false}\n## <span style=\"color:green\">{{< fa info-circle >}}</span> Summary & Grouping Behavior\nWhen you summarize a tibble grouped by more than one variable, each summary peels off the last group. You can change the default behavior by setting the `.groups` argument to a different value, e.g., \"drop\" to drop all grouping or \"keep\" to preserve the same groups. The default is \"drop_last\". \n:::\n\n## Remove Grouping: `ungroup()`\n\n```{r}\ndaily |> \n  ungroup() \n```\n\n## New Alternative for Grouping: `.by`\n\n```{r}\nflights |> \n  summarize(\n    delay = mean(dep_delay, na.rm = TRUE), \n    n = n(),\n    .by = month # <30>\n  )\n```\n\n30. `.by` works with all verbs and has the advantage that you don’t need to use the `.groups` argument to suppress the grouping message or `ungroup()` when you’re done.\n\n## Select Specific Rows Per Group: `slice_*`\n\nThere are five handy functions that allow you extract specific rows within each group:\n\n::: {.incremental}\n* `df |> slice_head(n = 1)` takes the first row from each group.\n* `df |> slice_tail(n = 1)` takes the last row in each group.\n* `df |> slice_min(x, n = 1)` takes the row with the smallest value of column x.\n* `df |> slice_max(x, n = 1)` takes the row with the largest value of column x.\n* `df |> slice_sample(n = 1)` takes one random row.\n:::\n\n. . . \n\nLet's find the flights that are most delayed upon arrival at each destination. \n\n\n## Select Specific Rows Per Group: `slice_*` \n\n\n```{r}\nflights |> \n  group_by(dest) |> \n  slice_max(arr_delay, n = 1) |> # <31>\n  relocate(dest) \n```\n\n31. You can vary `n` to select more than one row, or instead of `n =`, you can use `prop = 0.1` to select (e.g.) 10% of the rows in each group.\n\n::: aside\nThere are 105 groups but 108 rows! Why? `slice_min()` and `slice_max()` keep tied values so `n = 1` means \"give us all rows with the highest value.\" If you want exactly one row per group you can set `with_ties = FALSE`.\n:::\n\n# Merging Data {.section-title background-color=\"#4B2E83\"}\n\n## Why Merge Data?\n\nIn practice, we often collect data from different sources. To analyze the data, we usually must first combine (merge) them.\n\n. . . \n\nFor example, imagine you would like to study county-level patterns with respect to age and grocery spending. However, you can only find,\n\n* County level age data from the US Census, and \n* County level grocery spending data from the US Department of Agriculture\n\n. . . \n\nMerge the data!!\n\n. . . \n\nTo do this we'll be using the various **join** functions from the `dplyr` package. \n\n## Joining in Concept\n\nWe need to think about the following when we want to merge data frames A and B:\n\n::: {.fragment}\n* Which rows are we keeping from each data frame?\n:::\n\n::: {.fragment}\n* Which columns are we keeping from each data frame?\n:::\n\n::: {.fragment .fade-in}\n::: {.fragment .highlight-red}\n* Which variables determine whether rows match?\n:::\n:::\n\n## Keys\n\nKeys are the way that two datasets are connected to one another. The two types of keys are: \n\n::: {.incremental}\n1. **Primary**: a variable or set of variables that uniquely identifies each observation.\n    i) When more than one variable makes up the primary key it's called a **compound key**\n2. **Foreign**: a variable (or set of variables) that corresponds to a primary key in another table.\n:::\n\n## Primary Keys <span style=\"color:#B7A57A\">{{< fa scroll >}}</span> {.scrollable} \n\nLet's look at our data to gain a better sense of what this all means. \n\n::: {.panel-tabset}\n\n### `airlines` \n\n::: {.smaller-font}\n`airlines` records two pieces of data about each airline: its carrier code and its full name. You can identify an airline with its two letter carrier code, making `carrier` the primary key.\n:::\n\n```{r}\nairlines \n```\n\n### `airports`\n\n::: {.smaller-font}\n`airports` records data about each airport. You can identify each airport by its three letter airport code, making `faa` the primary key.\n:::\n\n```{r}\nairports\n```\n\n\n### `planes`\n\n::: {.smaller-font}\n`planes` records data about each plane. You can identify a plane by its tail number, making `tailnum` the primary key.\n:::\n\n```{r}\nplanes\n```\n\n\n### `weather`\n\n::: {.smaller-font}\n`weather` records data about the weather at the origin airports. You can identify each observation by the combination of location and time, making `origin` and `time_hour` the compound primary key.\n:::\n\n```{r}\nweather\n```\n\n### `flights`\n\n::: {.smaller-font}\n`flights` has three variables (`time_hour`, `flight`, `carrier`) that uniquely identify an observation. More significantly, however, it contains **foreign keys** that correspond to the primary keys of the other datasets.\n:::\n\n```{r}\nflights\n```\n\n:::\n\n\n## Foreign Keys\n\n![Note: grey shading indicates the primary key for that particular dataset.](images/relational.png){fig-align=\"center\"}\n\n::: {.incremental}\n* `flights$origin` --> `airports$faa`\n* `flights$dest` --> `airports$faa`\n* `flights$origin`-`flights$time_hour` --> `weather$origin`-`weather$time_hour`.\n* `flights$tailnum` --> `planes$tailnum`\n* `flights$carrier` --> `airlines$carrier`\n:::\n\n## Checking Keys\n\nA nice feature of these data are that the primary and foreign keys have the same name and almost every variable name used across multiple tables has the same meaning.^[With the exception of `year`: it means year of departure in `flights` and year of manufacture in `planes`. ] This isn't always the case!^[We'll cover how to handle this shortly.]\n\n. . . \n\nIt is good practice to make sure your primary keys actually uniquely identify an observation and that they don't have any missing values. \n\n. . . \n\n```{r}\n#| output-location: fragment\nplanes |> \n  count(tailnum) |> # <1>\n  filter(n > 1) # <1> \n```\n\n1. If your primary keys uniquely identify each observation you'll get an empty tibble in return. \n\n. . . \n\n```{r}\nplanes |> \n  filter(is.na(tailnum)) # <2>\n```\n\n2. If none of your primary keys are missing you'll get an empty tibble in return here too. \n\n## Surrogate Keys\n\nSometimes you'll want to create an index of your observations to serve as a surrogate key because the compound primary key is not particlarly easy to reference. \n\n. . . \n\nFor example, our `flights` dataset has three variables that uniquely identify each observation: `time_hour`, `carrier`, `flight`.\n\n. . . \n\n```{r}\n#| output-location: fragment\nflights2 <- flights |> \n  mutate(id = row_number(), .before = 1) # <3> \nflights2\n```\n\n3. `row_number()` simply specifies the row number of the dataframe. \n\n## Basic (Equi-) Joins\n\nAll join functions have the same basic interface: they take a **pair** of data frames and return **one** data frame. \n\n. . . \n\nThe order of the rows and columns is primarily going to be determined by the first data frame. \n\n. . . \n\n`dplyr` has two types of joins: *mutating* and *filtering.* \n\n<br>\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n#### Mutating Joins \nAdd new variables to one data frame from matching observations from another data frame. \n\n* `left_join()`\n* `right_join()`\n* `inner_join()`\n* `full_join()`\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment}\n#### Filtering Joins \nFilter observations from one data frame based on whether or not they match an observation in another data frame. \n\n* `semi_join()`\n* `anti-join()`\n:::\n\n:::\n\n::::\n\n## `Mutating Joins`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup.png)\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup2.png)\n:::\n:::\n\n::::\n\n## `left_join()` <span style=\"color:#B7A57A\">{{< fa scroll >}}</span> {.scrollable} \n\n![](images/joins_left.png){fig-align=\"center\"}\n\n::: aside\n::: {.incremental}\n* The most common type of join\n* Appends columns from `y` to `x` by the rows in `x`\n    + `NA` added if there is nothing from `y`\n* Natural join: when all variables that appear in both datasets are used as the join key\n    + If the join_by() argument is not specified, `left_join()` will automatically join by all columns that have names and values in common. \n:::\n:::\n\n## `left_join` in `nycflights13`\n\n```{r}\nflights2 <- flights |> \n  select(year, time_hour, origin, dest, tailnum, carrier)\n```\n\nWith only the pertinent variables from the `flights` dataset, we can see how a `left_join` works with the `airlines` dataset. \n\n```{r}\n#| output-location: fragment\n#| message: true\nflights2 |>\n  left_join(airlines)\n```\n\n## Different variable meanings\n\n```{r}\n#| output-location: fragment\n#| message: true\nflights2 |> \n  left_join(planes)\n```\n\n. . . \n\nWhen we try to do this, however, we get a bunch of `NA`s. Why? \n\n## Different variable meanings\n\n```{r}\n#| message: true\nflights2 |> \n  left_join(planes)\n```\n\n*Join is trying to use tailnum and year as a compound key.* While both datasets have `year` as a variable, they mean different things. Therefore, we need to be explicit here about what to join by. \n\n## Different variable meanings\n\n```{r}\n#| output-location: fragment\nflights2 |> \n  left_join(planes, join_by(tailnum)) # <4>\n```\n\n4. `join_by(tailnum)` is short for `join_by(tailnum == tailnum)` making these types of basic joins equi joins. \n\n::: aside\nWhen you have the same variable name but they mean different things you can specify a particular suffix with the `suffix` argument.\n:::\n\n## Different variable names\n\nIf you have keys that have the same meaning (values) but are named different things in their respective datasets you'd also specify that with `join_by()`\n\n. . . \n\n```{r}\n#| output-location: fragment\nflights2 |> \n  left_join(airports, join_by(dest == faa)) # <5>\n```\n\n5. `by = c(\"dest\" = \"faa\")` was the former syntax for this and you still might see that in older code. \n\n. . . \n\nThis will match `dest` to `faa` for the join and then drop `faa`. \n\n## Different variable names\n\nYou can request `dplyr` to keep both keys with `keep = TRUE` argument. \n\n. . . \n\n```{r}\n#| output-location: fragment\nflights2 |> \n  left_join(airports, join_by(dest == faa), keep = TRUE) \n```\n\n## `right_join()`\n\n![Has the same interface as a left_join but keeps all rows in `y` instead of `x`](images/joins_right.png){fig-align=\"center\"}\n\n## `inner_join()`\n\n![Has the same interface as a left_join but only keeps rows that occur in both x and y](images/joins_inner.png){fig-align=\"center\"}\n\n## `full_join()`\n\n![Has the same interface as a left_join but keeps all rows in either x or y](images/joins_full.png){fig-align=\"center\"}\n\n## `Filtering Joins`\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup.png)\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n<br>\n\n::: {.fragment}\n![](images/joins_setup2.png)\n:::\n:::\n\n::::\n\n## `semi_join()`\n\n![Keeps all rows in x that have a match in y](images/joins_semi.png){fig-align=\"center\"}\n\n\n## `semi_join()` in `nycflights13`\n\nWe could use a semi-join to filter the airports dataset to show just the origin airports.\n\n. . . \n\n```{r}\n#| output-location: fragment\nairports |> \n  semi_join(flights2, join_by(faa == origin))\n```\n\n\n## `anti_join()`\n\n![Returns all rows in x that don’t have a match in y](images/joins_anti.png){fig-align=\"center\"}\n\n## `anti_join()` in `nycflights13`\n\nWe can find rows that are missing from airports by looking for flights that don’t have a matching destination airport.\n\n. . . \n\n```{r}\n#| output-location: fragment\nairports |> \n  anti_join(flights2, join_by(faa == origin))\n```\n\n::: aside\nThis type of join is useful for finding missing values that are implicit in the data (i.e. `NA`s that don't show up in the data but only exist as an absence.)\n:::\n\n## More Than One Match\n\n![](images/joins_match-types.png){fig-align=\"center\"}\n\n. . . \n\nThere are three possible outcomes for a row in x:\n\n::: {.incremental}\n* If it doesn’t match anything, it’s dropped.\n* If it matches 1 row in y, it’s preserved.\n* If it matches more than 1 row in y, it’s duplicated once for each match.\n:::\n\n. . . \n\nWhat happens if we match on more than one row? \n\n## More Than One Match\n\n```{r}\n#| output-location: fragment\n#| warning: true\ndf1 <- tibble(key = c(1, 2, 2), val_x = c(\"x1\", \"x2\", \"x3\"))\ndf2 <- tibble(key = c(1, 2, 2), val_y = c(\"y1\", \"y2\", \"y3\"))\n\ndf1 |> \n  inner_join(df2, join_by(key))\n```\n\n\n. . . \n\nIf you're doing this deliberately, set relationship = \"many-to-many\", as the warning suggests.\n\n::: aside\nGiven their nature, filtering joins never duplicate rows like mutating joins do. They will only ever return a subset of the datasets.\n:::\n\n## Non-Equi Joins\n\nThe joins we've discussed thus far have all been equi-joins, where the rows match if the x key equals the y key. But you can also specify other types of relationships. \n\n. . . \n\n`dplyr` has four different types of non-equi joins: \n\n. . . \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* **Cross joins** match every pair of rows.\n:::\n\n::: {.column width=\"50%\"}\n\n![](images/joins_cross.png){width=25% .absolute top=150 right=150}\n\n:::\n::::\n\n::: aside\nCross joins, aka self-joins, are useful when generating permutations (e.g. creating every possible combination of values). This comes in handy when creating datasets of predicted probabilities for plotting in ggplot. \n:::\n\n## Non-Equi Joins\n\nThe joins we've discussed thus far have all been equi-joins, where the rows match if the x key equals the y key. But you can also specify other types of relationships. \n\n`dplyr` has four different types of non-equi joins: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* **Cross joins** match every pair of rows.\n* **Inequality joins** use <, <=, >, and >= instead of ==.\n    * **Overlap joins** are a special type of inequality join designed to work with ranges^[Overlap joins provide three helpers that use inequality joins to make it easier to work with intervals: `between()`, `within()`, `overlaps()`. Read more about their functionality and specifications [here](https://dplyr.tidyverse.org/reference/join_by.html?q=within#overlap-joins).].\n\n:::\n\n::: {.column width=\"50%\"}\n![](images/joins_inequality.png){width=30% .absolute top=158 right=120}\n:::\n::::\n\n::: aside\nInequality joins can be used to restrict the cross join so that instead of generating all permutations, we generate all combinations.\n:::\n\n## Non-Equi Joins\n\nThe joins we've discussed thus far have all been equi-joins, where the rows match if the x key equals the y key. But you can also specify other types of relationships. \n\n`dplyr` has four different types of non-equi joins: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n* **Cross joins** match every pair of rows.\n* **Inequality joins** use <, <=, >, and >= instead of ==.\n    * **Overlap joins** are a special type of inequality join designed to work with ranges.\n* **Rolling joins** are similar to inequality joins but only find the closest match.\n\n:::\n\n::: {.column width=\"50%\"}\n![](images/joins_rolling.png){width=42% .absolute top=155 right=35}\n:::\n::::\n\n::: aside\nRolling joins are a special type of inequality join where instead of getting every row that satisfies the inequality, you get just the closest row. You can turn any inequality join into a rolling join by adding closest().\n:::\n\n# Tidying and Reshaping Data {.section-title background-color=\"#4B2E83\"}\n\n# {data-menu-title=\"`tidyr`\" background-image=\"images/tidyr.png\" background-size=\"contain\" background-position=\"center\" .section-title background-color=\"#B7A57A\"}\n\n## What is Tidy Data\n\n**Tidy data^[Read the original article [here](https://www.jstatsoft.org/article/view/v059i10).]** (aka \"long data\") are such that:\n\n![](images/tidy-1.png){fig-align=\"center\"}\n\n::: {.incremental}\n1. The values for a single variable are in their own column.\n2. The values for a single observation are in their own row.\n3. There is only one value per cell.\n:::\n\n## Why do we Want Tidy Data?\n\n::: {.incremental}\n* **Easier to understand** many rows than many columns^[Placing variables in columns also leverages `R`'s vectorized nature, i.e. most built-in `R` functions work with values of vectors.]\n* Required for **plotting** in `ggplot2`^[In fact, all tidyverse functions are designed to work with tidy data.]\n* Required for many types of **statistical procedures** (e.g. hierarchical or mixed effects models)\n* Fewer issues with **missing values and \"imbalanced\"** repeated measures data\n* Having a consistent method for storing data means it's easier to learn the tools to work with it since there's an underlying uniformity.\n:::\n\n. . . \n\nMost real-world data is not tidy because data are often organized for goals other than analysis (i.e. data entry) and most people aren't familiar with the principles of tidy data. \n\n## Slightly \"Messy\" Data\n\n::::{.columns}\n:::{.column width=\"60%\"}\n\n| **Program**     | **First Year** | **Second Year** |\n|-----------------|-----------:|---------:|\n| Evans School    |     10     |    6    |\n| Arts & Sciences |      5     |    6    |\n| Public Health   |      2     |    3    |\n| Other           |      5     |    1    |\n\n:::\n:::{.column width=\"40%\"}\n\n* What is an **observation**?\n    + A group of students from a program of a given year\n    \n\n* What are the **variables**?\n    + Program, Year\n\n\n* What are the **values**?\n    + Program: Evans School, Arts & Sciences, Public Health, Other\n    + Year: First, Second -- **in column headings. Bad!**\n    + Count: **spread over two columns!**\n:::\n::::\n\n## Tidy Version\n\n::::{.columns}\n:::{.column width=\"50%\"}\n\n| **Program**     | **Year** | **Count** |\n|-----------------|-----------:|---------:|\n| Evans School    |     First |    10   |\n| Evans School    |     Second   |    6    |\n| Arts & Sciences |     First |    5    |\n| Arts & Sciences |     Second   |    6    |\n| Public Health   |     First |    2    |\n| Public Health   |     Second   |    3    |\n| Other           |     First |    5    |\n| Other           |     Second   |    1    |\n:::\n:::{.column width=\"50%\"}\n* Each variable is a column.\n\n* Each observation is a row.\n\n* Each cell has a single value.\n:::\n::::\n\n## Billboard Data\n\n```{r}\n#| echo: false\nglimpse(billboard_2000_raw)\n```\n\n. . . \n\n\\\n\nThis data is just ugly-messy!\n\n::: aside\nWeek columns continue up to `wk76`!\n:::\n\n## How is Billboard currently organized?\n\n::: {.incremental}\n* What are the **observations** in the data?\n    + Song on the Billboard chart each week\n* What are the **variables** in the data?\n    + Year, artist, track, song length, date entered Hot 100, week since first entered Hot 100 (**spread over many columns**), rank during week (**spread over many columns**)\n* What are the **values** in the data?\n    + e.g. 2000; 3 Doors Down; Kryptonite; 3 minutes 53 seconds; April 8, 2000; Week 3 (**stuck in column headings**); rank 68 (**spread over many columns**)\n:::\n\n## `tidyr`\n\nThe `tidyr` package provides functions to tidy up data. \n\n. . . \n\n**Key functions:**\n\n* **`pivot_longer()`**: takes a set of columns and pivots them down (\"longer\") to make two new columns (which you can name yourself): \n    * A `name` column that stores the original column names\n    * A `value` with the values in those original columns\n\n. . . \n\n* **`pivot_wider()`**: inverts `pivot_longer()` by taking two columns and pivoting them up and across (\"wider\") into multiple columns\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n::: {.incremental}\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. `names_to`: Names the new variable that is stored in multiple columns\n3. `values_to`: Names the variable stored in the cell values\n:::\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. **`names_to`: Names the new variable that is stored in multiple columns**\n3. `values_to`: Names the variable stored in the cell values\n\n![](images/pivot_longer2_column_names.png){fig-align=\"center\"}\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. `names_to`: Names the new variable that is stored in multiple columns\n3. **`values_to`: Names the variable stored in the cell values**\n\n![](images/pivot_longer3_cell_values.png){fig-align=\"center\"}\n\n## `pivot_longer()`\n\nThis function usually takes three arguments:\n\n1. `cols`: The columns that need to be pivoted (are not variables)\n2. `names_to`: Names the new variable that is stored in multiple columns\n3. `values_to`: Names the variable stored in the cell values\n\n![](images/pivot_longer1_variables.png){fig-align=\"center\"}\n\n## `pivot_longer()` Example\n\n```{r}\n#| output-location: fragment \nbillboard_2000 <- billboard_2000_raw |> \n  pivot_longer(cols = starts_with(\"wk\"), # <1>\n               names_to =\"week\",\n               values_to = \"rank\")\n\nbillboard_2000 |> head(10)\n```\n\n1. `starts_with()` is one of the helper functions from [`tidyselect`](https://tidyselect.r-lib.org/index.html) that helps select certain common patterns. We could have also used `cols = wk1:wk76`. \n\n. . . \n\nNow we have a single week column!\n\n## Lots of Missing Values?!\n\n```{r}\n#| output-location: fragment \nglimpse(billboard_2000)\n```\n\n::: {.fragment}\nIt looks like 2 Pac's song \"Baby Don't Cry\" was only on the Billboard Hot 100 for 7 weeks and then dropped off the charts. \n:::\n. . . \n\n```{r}\n#| output-location: fragment \nsummary(billboard_2000$rank)\n```\n\n::: {.fragment}\nWe don't want to keep the `r sum(is.na(billboard_2000$rank))` rows with missing ranks.\n:::\n\n## Pivoting Better: `values_drop_na`\n\nAdding the argument `values_drop_na = TRUE` to `pivot_longer()` will remove rows with missing ranks. Since these `NA`s don’t really represent unknown observations (i.e. they were forced to exist by the structure of the dataset) this is an appropriate approach here. \n\n```{r}\n#| output-location: fragment \n#| code-line-numbers: \"|5\"\nbillboard_2000 <- billboard_2000_raw %>%\n  pivot_longer(cols = wk1:wk76, \n               names_to = \"week\", \n               values_to = \"rank\", \n               values_drop_na = TRUE)\nsummary(billboard_2000$rank)\n```\n\n. . . \n\nNo more `NA` values!\n\n```{r}\n#| output-location: fragment \ndim(billboard_2000)\n```\n\n. . . \n\nAnd way fewer rows!\n\n## `parse_number()`\n\nThe week column is of the type `character`, but it should be `numeric.`\n\n```{r}\n#| output-location: fragment \nhead(billboard_2000$week)\n```\n\n. . . \n\n`parse_number()` grabs just the numeric information from a character string:\n\n```{r}\n#| output-location: fragment \nbillboard_2000 <- billboard_2000 |> \n    mutate(week = parse_number(week)) # <2>\nsummary(billboard_2000$week)\n```\n2. You can use `mutate()` to overwrite existing columns. \n\n## Use `pivot_longer` arguments\n\nAlternatively (and more efficiently), there are a number of optional arguments for `pivot_longer` that are meant to help deal with naming issues.\n\n. . . \n\n```{r}\n#| output-location: fragment\nbillboard_2000 <- billboard_2000_raw %>%\n  pivot_longer(starts_with(\"wk\"), \n               names_to        = \"week\", \n               values_to       = \"rank\",\n               values_drop_na  = TRUE,\n               names_prefix    = \"wk\", # <3>\n               names_transform = list(week = as.integer)) # <4>\n\nhead(billboard_2000, 5)\n```\n\n3. `names_prefix` is used to remove \"wk\" from the values of `week`\n4. `names_transform` converts `week` into an integer number.\n\n## Multiple Variables in Column Names\n\nA more challenging situation occurs when you have multiple pieces of information crammed into the column names, and you would like to store these in separate new variables.\n\n. . . \n\nThis dataset contains tuberculosis diagnoses collected by the World Health Organization. \n\n```{r}\n#| output-location: fragment\nwho2\n```\n\n. . . \n\nThe first two columns are self explanatory but what's going on with the rest?\n\n## Multiple Variables in Column Names\n\nData documentation and some minor investigation would lead you to figure out that the three elements in each of these column names are actually data!\n\n* The first piece, `sp`/`sn`/`rel`/`ep`, describes the method used for the diagnosis\n* The second piece, `m`/`f` is the gender (coded as a binary variable in this dataset)\n* The third piece, `014`/`1524`/`2534`/`3544`/`4554`/`5564`/`65` is the age range (014 represents 0-14, for example)\n\n. . . \n\nTo organize the six pieces of information in this dataset into six separate columns, we use `pivot_longer()` with a vector of column names for `names_to` and instructors for splitting the original variable names into pieces for `names_sep` as well as a column name for `values_to`!\n\n## Multiple Variables in Column Names\n\n```{r}\n#| output-location: fragment\nwho2 |> \n  pivot_longer(\n    cols = !(country:year),\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_sep = \"_\", # <5>\n    values_to = \"count\"\n  )\n```\n\n5. You can use `names_pattern` instead of `names_sep` to extract variables from more complicated naming scenarios if you are familiar with regular expressions. \n\n## Variable & Values in Column Names\n\nThis dataset contains data about five families, with the names and dates of birth of up to two children. \n\n```{r}\n#| output-location: fragment\nhousehold\n```\n\n. . . \n\nThe new challenge in this dataset is that the column names contain the names of two variables (`dob`, `name`) and the values of another (`child`, with values `1` or `2`).\n\n## Variable & Values in Column Names\n\n```{r}\n#| output-location: column-fragment\nhousehold |> \n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), # <6>\n    names_sep = \"_\", \n    values_drop_na = TRUE # <7> \n  )\n```\n\n6. `.value` isn’t the name of a variable but a unique value that tells `pivot_longer` to use the first component of the pivoted column name as a variable name in the output. \n7. Using `values_drop_na = TRUE` again since not every family has 2 children.\n\n. . . \n\n![](images/pivot_longer5_names-and-values.png){width=75% fig-align=\"center\"}\n\n## `pivot_wider`\n\n`pivot_wider()` is the opposite of `pivot_longer()`, which you use if you have data for the same observation taking up multiple rows.\n\n. . . \n\nHere's an example of data that we probably want to pivot wider (unless we want to plot each statistic in its own facet):\n\n```{r}\n#| echo: false\nlong_stats <- tibble(Group = c(rep(\"A\", 3), rep(\"B\", 3)),\n                     Statistic = rep(c(\"Mean\", \"Median\", \"SD\"), 2),\n                     Value = c(1.28, 1.0, 0.72, 2.81, 2, 1.33))\nlong_stats\n```\n\n. . . \n\nA common cue to use `pivot_wider()` is having measurements of different quantities in the same column.\n\n## `pivot_wider` Example \n\n```{r}\n#| output-location: fragment\nwide_stats <- long_stats |> \n  pivot_wider(id_cols = Group, # <8>\n              names_from = Statistic, # <9>\n              values_from = Value) # <10>\nwide_stats\n```\n\n8. `id_cols` is the column that uniquely identifies each row in the new dataset. Default is everything not in `names_from` and `values_from`.\n9. `names_from` provides the names that will be used for the new columns\n10. `values_from` provides the values that will be used to populate the cells of the new columns.\n\n. . . \n\n[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.html) also has a number of optional `names_*` and `values_*` arguments for more complicated transformations. \n\n. . . \n\n::: {.callout-warning icon=false}\n## <span style=\"color:orange\">{{< fa triangle-exclamation >}}</span> Nested Data\nIf there are multiple rows in the input that correspond to one cell in the output you'll get a list-column. This means that you 1) need to fix something in your code/data because it shouldn't be nested in this way or 2) need to use `unnest_wider()` or `unnest_longer()` in order to access this column of data. More on this [here](https://r4ds.hadley.nz/rectangling.html#unnesting). \n:::\n\n## Useful Resources\n\n. . . \n\n**Cheatsheets:**\n\n* [readr](https://rstudio.github.io/cheatsheets/data-import.pdf)\n* [dplyr](https://rstudio.github.io/cheatsheets/data-transformation.pdf)\n* [tidyr](https://rstudio.github.io/cheatsheets/tidyr.pdf)\n\n\n**Introductory Book:**\n\n[R for Data Science (2e)](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund\n\n# {data-menu-title=\"R Knowledge Comic\" .section-title background-image=\"images/r_knowledge.png\"}\n\n## CSSCR Consulting Services\n\nCSSCR is a resource center for the social science departments^[Constituent member departments include The College of Education, The Department of Anthropology, The Department of Communication, The Department of Economics, The Department of Geography, The Department of Political Science, The Department of Psychology, The Department of Sociology, The Jackson School of International Studies, and The School of Social Work] at the University of Washington.\n\n. . . \n\nAs you continue to learn `R` feel free to drop by with any/all of your `R` coding questions. Below are our hours for the quarter: \n\n```{r}\n#| echo: false\nlibrary(gt)\nhours <- tibble(day = c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"), \n                drop_in = c(rep(\"8am - 6pm\", 4), \"8am - 5pm\"), \n                evening = c(rep(\"6 - 9pm\", 4), \"\"))\n\nhours |> \n  gt(rowname_col = \"day\") |> \n  tab_header(title = \"The Center for Social Science Computation and Research\", \n             subtitle = \"Consulting Hours for Fall 2024\")  |> \n  cols_label(drop_in = \"In-Person\", \n             evening = \"Virtual\") |> \n  tab_footnote(footnote = \"Drop-in @ Savery 119\", \n               locations = cells_column_labels(columns = drop_in), \n               placement = \"right\") |> \n  tab_footnote(footnote = \"Online Via Zoom\", \n               locations = cells_column_labels(columns = evening), \n               placement = \"right\") |> \n  tab_options(footnotes.multiline = FALSE) |> \n  data_color(columns = drop_in, \n             palette = c(\"LightGoldenrodYellow\", \"PaleGoldenrod\")) |> \n  data_color(columns = evening, \n             palette = \"Purples\")\n\n```\n\n\n# Thanks!{.section-title background-color=\"#4B2E83\"}\n\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"svg","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","highlight-style":"a11y-dark","reference-location":"margin","incremental":false,"output-file":"data_wrangling_r.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.5.43","auto-stretch":true,"revealjs-plugins":["pointer"],"theme":"csscr_styles.scss","slideNumber":true,"chalkboard":true,"smaller":true,"previewLinks":true,"history":false,"progress":true,"code-annotations":"hover","pointer":{"color":"#b18eb1"}}}},"projectFormats":["html"]}